/* tslint:disable */
/* eslint-disable */
/**
 * Légifrance
 *  Afin de faciliter la réutilisation des données juridiques, la DILA met à disposition du public une API de Légifrance. Ce document a pour objectif de décrire les méthodes de l\'API Légifrance, présentées à l\'aide du framework Swagger. Vous pouvez également télécharger une [documentation complémentaire](https://www.legifrance.gouv.fr/contenu/Media/Files/pied-de-page/description-des-tris-et-filtres-de-l-api.xlsx) ainsi que des [exemples d’utilisation](https://www.legifrance.gouv.fr/contenu/Media/Files/pied-de-page/exemples-d-utilisation-de-l-api.docx) de l\'API.  Cet accès vous permet d’expérimenter l\'API sur un environnement de test et de vous familiariser avec les différentes méthodes.  À noter : - L\'environnement de test peut être indisponible. - Les appels sont limités par quotas.  Les mises à jour correctives et évolutives sont réalisées dans un premier temps sur cet environnement. L\'API mise à disposition correspond à celle utilisée par le site de Légifrance.  Les données ne sont pas identiques à celles de Production.  L\'API Légifrance est mise à disposition sous [conditions](https://www.legifrance.gouv.fr/contenu/pied-de-page/open-data-et-api).  Pour toute question, vous pouvez écrire à l\'adresse retours-legifrance-modernise@dila.gouv.fr.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: retours-legifrance-modernise@dila.gouv.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Requête de consultation d\'un accord d\'entreprise
 * @export
 * @interface AccoConsultRequest
 */
export interface AccoConsultRequest {
    /**
     * Identifiant de l\'accord d\'entreprise
     * @type {string}
     * @memberof AccoConsultRequest
     */
    'id': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof AccoConsultRequest
     */
    'searchedString'?: string;
}
/**
 * Objet représentant un accord d\'entreprise
 * @export
 * @interface Accord
 */
export interface Accord {
    /**
     * Date d\'effet de l\'accord
     * @type {string}
     * @memberof Accord
     */
    'dateEffet'?: string;
    /**
     * SIRET
     * @type {string}
     * @memberof Accord
     */
    'siret'?: string;
    /**
     * Liste des addresses postales
     * @type {Array<AdressePostale>}
     * @memberof Accord
     */
    'adressesPostales'?: Array<AdressePostale>;
    /**
     * Identifiant
     * @type {string}
     * @memberof Accord
     */
    'id'?: string;
    /**
     * Contenu du fichier attaché en base64
     * @type {string}
     * @memberof Accord
     */
    'data'?: string;
    /**
     * Code du signataire
     * @type {string}
     * @memberof Accord
     */
    'codeUniteSignataire'?: string;
    /**
     * Code APE
     * @type {string}
     * @memberof Accord
     */
    'codeApe'?: string;
    /**
     * IDCC
     * @type {string}
     * @memberof Accord
     */
    'codeIdcc'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof Accord
     */
    'origine'?: string;
    /**
     * Chemin vers le fichier attaché
     * @type {string}
     * @memberof Accord
     */
    'attachementUrl'?: string;
    /**
     * Raison sociale
     * @type {string}
     * @memberof Accord
     */
    'raisonSociale'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof Accord
     */
    'nature'?: string;
    /**
     * Chemin vers le fichier xml
     * @type {string}
     * @memberof Accord
     */
    'url'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof Accord
     */
    'dateFin'?: string;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof Accord
     */
    'idTechInjection'?: string;
    /**
     * Liste des signataires
     * @type {Array<string>}
     * @memberof Accord
     */
    'signataires'?: Array<string>;
    /**
     * Date de diffusion
     * @type {string}
     * @memberof Accord
     */
    'dateDiffusion'?: string;
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof Accord
     */
    'refInjection'?: string;
    /**
     * Indique si l\'accord consulté est conforme à la version intégrale
     * @type {boolean}
     * @memberof Accord
     */
    'conformeVersionIntegrale'?: boolean;
    /**
     * Liste des syndicats
     * @type {Array<Syndicat>}
     * @memberof Accord
     */
    'syndicats'?: Array<Syndicat>;
    /**
     * Titre du texte
     * @type {string}
     * @memberof Accord
     */
    'titreTexte'?: string;
    /**
     * Date du texte
     * @type {string}
     * @memberof Accord
     */
    'dateTexte'?: string;
    /**
     * Liste des thèmes
     * @type {Array<Theme>}
     * @memberof Accord
     */
    'themes'?: Array<Theme>;
    /**
     * 
     * @type {Attachment}
     * @memberof Accord
     */
    'attachment'?: Attachment;
    /**
     * Secteur d\'activité
     * @type {string}
     * @memberof Accord
     */
    'secteur'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accord
     */
    'relevantDate'?: string;
    /**
     * Numéro de l\'accord
     * @type {string}
     * @memberof Accord
     */
    'numero'?: string;
    /**
     * Taille du fichier attaché avec son unité
     * @type {string}
     * @memberof Accord
     */
    'fileSize'?: string;
    /**
     * Date de dépôt
     * @type {string}
     * @memberof Accord
     */
    'dateDepot'?: string;
    /**
     * Date de mise à jour
     * @type {string}
     * @memberof Accord
     */
    'dateMaj'?: string;
}
/**
 * Objet définissant une action effectuée par un article sur un texte
 * @export
 * @interface ActionChronoDTO
 */
export interface ActionChronoDTO {
    /**
     * Map listant les noeuds parents sur lesquels les actions sont faites (texte, section..). La clé correspond à l\'ID du parent.
     * @type {{ [key: string]: ParentChronoDTO; }}
     * @memberof ActionChronoDTO
     */
    'parents'?: { [key: string]: ParentChronoDTO; };
    /**
     * Action effectuée
     * @type {string}
     * @memberof ActionChronoDTO
     */
    'action'?: ActionChronoDTOActionEnum;
}

export const ActionChronoDTOActionEnum = {
    Creation: 'CREATION',
    Codification: 'CODIFICATION',
    Modification: 'MODIFICATION',
    Transfert: 'TRANSFERT',
    Abrogation: 'ABROGATION',
    Annulation: 'ANNULATION',
    Peremption: 'PEREMPTION',
    Disjonction: 'DISJONCTION',
    Rectification: 'RECTIFICATION',
    Substitution: 'SUBSTITUTION',
    Deplace: 'DEPLACE',
    Versement: 'VERSEMENT',
    Denonciation: 'DENONCIATION',
    Remplacement: 'REMPLACEMENT',
    Extension: 'EXTENSION',
    Elargissement: 'ELARGISSEMENT'
} as const;

export type ActionChronoDTOActionEnum = typeof ActionChronoDTOActionEnum[keyof typeof ActionChronoDTOActionEnum];

/**
 * Objet représentant une adresse postale
 * @export
 * @interface AdressePostale
 */
export interface AdressePostale {
    /**
     * Code postal
     * @type {string}
     * @memberof AdressePostale
     */
    'codePostal'?: string;
    /**
     * Ville
     * @type {string}
     * @memberof AdressePostale
     */
    'ville'?: string;
}
/**
 * Objet représentant une arborescence de dossier legislatif
 * @export
 * @interface Arborescence
 */
export interface Arborescence {
    /**
     * Liste des niveaux enfants
     * @type {Array<Niveau>}
     * @memberof Arborescence
     */
    'niveaux'?: Array<Niveau>;
    /**
     * Liste des liens de premier niveau
     * @type {Array<Lien>}
     * @memberof Arborescence
     */
    'liens'?: Array<Lien>;
}
/**
 * Objet représentant le détail d\'un article
 * @export
 * @interface Article
 */
export interface Article {
    /**
     * Historique => Spécifique conventions collectives
     * @type {string}
     * @memberof Article
     */
    'historique'?: string;
    /**
     * Identifiant de l\'article
     * @type {string}
     * @memberof Article
     */
    'id'?: string;
    /**
     * INAP
     * @type {string}
     * @memberof Article
     */
    'inap'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof Article
     */
    'dateFin'?: string;
    /**
     * Condition différée => Spécifique conventions collectives
     * @type {string}
     * @memberof Article
     */
    'conditionDiffere'?: string;
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof Article
     */
    'idTexte'?: string;
    /**
     * Texte HTML des informations complémentaires
     * @type {string}
     * @memberof Article
     */
    'infosComplementairesHtml'?: string;
    /**
     * Liste des liens de modification de l\'article
     * @type {Array<LienModification>}
     * @memberof Article
     */
    'lienModifications'?: Array<LienModification>;
    /**
     * Informations complémentaires
     * @type {string}
     * @memberof Article
     */
    'infosComplementaires'?: string;
    /**
     * Concaténation de l\'ensemble des titres de la chaine parente
     * @type {string}
     * @memberof Article
     */
    'fullSectionsTitre'?: string;
    /**
     * Liste d\'id de conteneurs
     * @type {Array<Conteneur>}
     * @memberof Article
     */
    'conteneurs'?: Array<Conteneur>;
    /**
     * Contenu nota
     * @type {string}
     * @memberof Article
     */
    'nota'?: string;
    /**
     * 
     * @type {Context}
     * @memberof Article
     */
    'context'?: Context;
    /**
     * Liste des versions du texte contenant l\'article
     * @type {Array<TextTitle>}
     * @memberof Article
     */
    'textTitles'?: Array<TextTitle>;
    /**
     * Identifiant ELI
     * @type {string}
     * @memberof Article
     */
    'idEli'?: string;
    /**
     * Liste des calipsos
     * @type {Array<string>}
     * @memberof Article
     */
    'calipsos'?: Array<string>;
    /**
     * Alias ELI
     * @type {string}
     * @memberof Article
     */
    'idEliAlias'?: string;
    /**
     * Liste des activités
     * @type {Array<string>}
     * @memberof Article
     */
    'activitePro'?: Array<string>;
    /**
     * Chronical ID
     * @type {string}
     * @memberof Article
     */
    'cid'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof Article
     */
    'etat'?: string;
    /**
     * Type
     * @type {string}
     * @memberof Article
     */
    'type'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof Article
     */
    'cidTexte'?: string;
    /**
     * Autres liens de l\'article
     * @type {Array<Lien>}
     * @memberof Article
     */
    'lienAutres'?: Array<Lien>;
    /**
     * Version précédente
     * @type {string}
     * @memberof Article
     */
    'versionPrecedente'?: string;
    /**
     * Informations restructuration de branche
     * @type {string}
     * @memberof Article
     */
    'infosRestructurationBranche'?: string;
    /**
     * Numéro du bulletin officiel
     * @type {string}
     * @memberof Article
     */
    'numeroBo'?: string;
    /**
     * Liste des liens de concordance de l\'article
     * @type {Array<LienConcorde>}
     * @memberof Article
     */
    'lienConcordes'?: Array<LienConcorde>;
    /**
     * Titre de la section parente
     * @type {string}
     * @memberof Article
     */
    'sectionParentTitre'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof Article
     */
    'origine'?: string;
    /**
     * Texte HTML des informations restructuration de branche
     * @type {string}
     * @memberof Article
     */
    'infosRestructurationBrancheHtml'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof Article
     */
    'nature'?: string;
    /**
     * Liste des numéros de brochure
     * @type {Array<string>}
     * @memberof Article
     */
    'numeroBrochure'?: Array<string>;
    /**
     * Contenu nota au format HTML
     * @type {string}
     * @memberof Article
     */
    'notaHtml'?: string;
    /**
     * Contenu textuel de l\'article
     * @type {string}
     * @memberof Article
     */
    'texte'?: string;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof Article
     */
    'idTechInjection'?: string;
    /**
     * Liste des numéros de l\'article
     * @type {Array<string>}
     * @memberof Article
     */
    'computedNums'?: Array<string>;
    /**
     * Liste des liens de citation de l\'article
     * @type {Array<LienCitation>}
     * @memberof Article
     */
    'lienCitations'?: Array<LienCitation>;
    /**
     * Liste des versions de l\'article
     * @type {Array<ArticleVersion>}
     * @memberof Article
     */
    'articleVersions'?: Array<ArticleVersion>;
    /**
     * Renvoi sur contenu d\'article (Exemple : (1))
     * @type {string}
     * @memberof Article
     */
    'renvoi'?: string;
    /**
     * Version
     * @type {string}
     * @memberof Article
     */
    'versionArticle'?: string;
    /**
     * Numéro d\'ordre permettant le tri des articles dans leur élément parent.
     * @type {number}
     * @memberof Article
     */
    'ordre'?: number;
    /**
     * Date de début si extension
     * @type {string}
     * @memberof Article
     */
    'dateDebutExtension'?: string;
    /**
     * Date de fin si extension
     * @type {string}
     * @memberof Article
     */
    'dateFinExtension'?: string;
    /**
     * Numéro de l\'article
     * @type {string}
     * @memberof Article
     */
    'num'?: string;
    /**
     * Identifiant technique de la section parente
     * @type {string}
     * @memberof Article
     */
    'sectionParentId'?: string;
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof Article
     */
    'refInjection'?: string;
    /**
     * Surtitre => Spécifique conventions collectives
     * @type {string}
     * @memberof Article
     */
    'surtitre'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof Article
     */
    'dateDebut'?: string;
    /**
     * Contenu HTML de l\'article
     * @type {string}
     * @memberof Article
     */
    'texteHtml'?: string;
    /**
     * Chronical ID de la section parente
     * @type {string}
     * @memberof Article
     */
    'sectionParentCid'?: string;
}
/**
 * Requête pour récupérer un article par son Chronical ID
 * @export
 * @interface ArticleCidRequest
 */
export interface ArticleCidRequest {
    /**
     * Chronical ID de l\'article
     * @type {string}
     * @memberof ArticleCidRequest
     */
    'cid': string;
}
/**
 * requête de consultation d\'un article du fonds data_article avec son ID et son numéro
 * @export
 * @interface ArticleConsultWithIdAndNum
 */
export interface ArticleConsultWithIdAndNum {
    /**
     * ID du LEGITEXT cible
     * @type {string}
     * @memberof ArticleConsultWithIdAndNum
     */
    'id'?: string;
    /**
     * Numéro de l\'article cible
     * @type {string}
     * @memberof ArticleConsultWithIdAndNum
     */
    'num'?: string;
}
/**
 * Objet représentant un lien vers un article
 * @export
 * @interface ArticleDTO
 */
export interface ArticleDTO {
    /**
     * Identifiant de l\'article
     * @type {string}
     * @memberof ArticleDTO
     */
    'id'?: string;
    /**
     * Liste des modifications sur le texte (Utilisée pour les anciens textes)
     * @type {Array<ModificationDTO>}
     * @memberof ArticleDTO
     */
    'modifications'?: Array<ModificationDTO>;
    /**
     * Date de début de la version de l\'article
     * @type {string}
     * @memberof ArticleDTO
     */
    'dateDebut'?: string;
    /**
     * Identifiant du texte de l\'article
     * @type {string}
     * @memberof ArticleDTO
     */
    'idText'?: string;
    /**
     * Nature du texte de l\'article
     * @type {string}
     * @memberof ArticleDTO
     */
    'nature'?: ArticleDTONatureEnum;
    /**
     * Nom de l\'article (concaténation titre texte + num article)
     * @type {string}
     * @memberof ArticleDTO
     */
    'name'?: string;
    /**
     * Chronical ID de l\'article (Non utilisé)
     * @type {string}
     * @memberof ArticleDTO
     */
    'cid'?: string;
    /**
     * Date de fin de la version de l\'article
     * @type {string}
     * @memberof ArticleDTO
     */
    'dateFin'?: string;
}

export const ArticleDTONatureEnum = {
    Loda: 'LODA',
    Jorf: 'JORF',
    Code: 'CODE',
    Kali: 'KALI',
    Jorfcont: 'JORFCONT'
} as const;

export type ArticleDTONatureEnum = typeof ArticleDTONatureEnum[keyof typeof ArticleDTONatureEnum];

/**
 * Requête pour récupérer un article par son Eli ou son alias.
 * @export
 * @interface ArticleIdEliOrAliasRequest
 */
export interface ArticleIdEliOrAliasRequest {
    /**
     * ID Eli ou alias de l\'article
     * @type {string}
     * @memberof ArticleIdEliOrAliasRequest
     */
    'idEliOrAlias': string;
}
/**
 * Objet définissant un article ayant modifié un texte
 * @export
 * @interface ArticleModificateurDTO
 */
export interface ArticleModificateurDTO {
    /**
     * ID de l\'article
     * @type {string}
     * @memberof ArticleModificateurDTO
     */
    'id'?: string;
    /**
     * Titre de l\'article modificateur (titre du texte + numéro article)
     * @type {string}
     * @memberof ArticleModificateurDTO
     */
    'title'?: string;
    /**
     * Date de début de l\'article
     * @type {string}
     * @memberof ArticleModificateurDTO
     */
    'dateDebutCible'?: string;
    /**
     * Nature/type de l\'article
     * @type {string}
     * @memberof ArticleModificateurDTO
     */
    'nature'?: ArticleModificateurDTONatureEnum;
    /**
     * Map listant les actions effectuées par cet article sur le texte. La clé correspond au type d\'action.
     * @type {{ [key: string]: ActionChronoDTO; }}
     * @memberof ArticleModificateurDTO
     */
    'actions'?: { [key: string]: ActionChronoDTO; };
}

export const ArticleModificateurDTONatureEnum = {
    Loda: 'LODA',
    Jorf: 'JORF',
    Code: 'CODE',
    Kali: 'KALI',
    Jorfcont: 'JORFCONT'
} as const;

export type ArticleModificateurDTONatureEnum = typeof ArticleModificateurDTONatureEnum[keyof typeof ArticleModificateurDTONatureEnum];

/**
 * Requête pour récupérer un article par son identifiant
 * @export
 * @interface ArticleRequest
 */
export interface ArticleRequest {
    /**
     * Identifiant de l\'article
     * @type {string}
     * @memberof ArticleRequest
     */
    'id': string;
}
/**
 * Objet représentant les métadonnées d\'une version d\'un article
 * @export
 * @interface ArticleVersion
 */
export interface ArticleVersion {
    /**
     * Numéro de l\'article
     * @type {string}
     * @memberof ArticleVersion
     */
    'numero'?: string;
    /**
     * Date de début de la version
     * @type {string}
     * @memberof ArticleVersion
     */
    'dateDebut'?: string;
    /**
     * Numéro d\'ordre de l\'article. Sert au tri des articles au sein de leur élément parent (section ou texte)
     * @type {number}
     * @memberof ArticleVersion
     */
    'ordre'?: number;
    /**
     * Version
     * @type {string}
     * @memberof ArticleVersion
     */
    'version'?: string;
    /**
     * Identifiant de l\'article
     * @type {string}
     * @memberof ArticleVersion
     */
    'id'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof ArticleVersion
     */
    'etat'?: string;
    /**
     * Date de fin de la version
     * @type {string}
     * @memberof ArticleVersion
     */
    'dateFin'?: string;
}
/**
 * Objet représentant un fichier joint à un texte
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * Mots clés
     * @type {string}
     * @memberof Attachment
     */
    'keywords'?: string;
    /**
     * Taille du contenu
     * @type {number}
     * @memberof Attachment
     */
    'content_length'?: number;
    /**
     * Titre
     * @type {string}
     * @memberof Attachment
     */
    'title'?: string;
    /**
     * Langue
     * @type {string}
     * @memberof Attachment
     */
    'language'?: string;
    /**
     * Type de fichier
     * @type {string}
     * @memberof Attachment
     */
    'content_type'?: string;
    /**
     * Date
     * @type {string}
     * @memberof Attachment
     */
    'date'?: string;
    /**
     * Nom
     * @type {string}
     * @memberof Attachment
     */
    'name'?: string;
    /**
     * Auteur
     * @type {string}
     * @memberof Attachment
     */
    'author'?: string;
    /**
     * Contenu du fichier textuel
     * @type {string}
     * @memberof Attachment
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface BoccAndTextListRequest
 */
export interface BoccAndTextListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof BoccAndTextListRequest
     */
    'pageSize': number;
    /**
     * 
     * @type {string}
     * @memberof BoccAndTextListRequest
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoccAndTextListRequest
     */
    'intervalPublication'?: string;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof BoccAndTextListRequest
     */
    'pageNumber': number;
    /**
     * 
     * @type {string}
     * @memberof BoccAndTextListRequest
     */
    'idcc'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoccAndTextListRequest
     */
    'sortValue'?: string;
}
/**
 * 
 * @export
 * @interface BoccConsultRequest
 */
export interface BoccConsultRequest {
    /**
     * 
     * @type {string}
     * @memberof BoccConsultRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BoccConsultRequest
     */
    'forGlobalBocc'?: boolean;
}
/**
 * 
 * @export
 * @interface BoccGlobalListResponse
 */
export interface BoccGlobalListResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof BoccGlobalListResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof BoccGlobalListResponse
     */
    'totalResultNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof BoccGlobalListResponse
     */
    'totalResultIdcc'?: number;
    /**
     * 
     * @type {Array<EsParutionBocc>}
     * @memberof BoccGlobalListResponse
     */
    'results'?: Array<EsParutionBocc>;
    /**
     * 
     * @type {number}
     * @memberof BoccGlobalListResponse
     */
    'totalResultBocc'?: number;
}
/**
 * 
 * @export
 * @interface BoccListRequest
 */
export interface BoccListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof BoccListRequest
     */
    'pageSize': number;
    /**
     * 
     * @type {string}
     * @memberof BoccListRequest
     */
    'idMainBocc'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BoccListRequest
     */
    'searchForTextsBocc'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BoccListRequest
     */
    'intervalPublication'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BoccListRequest
     */
    'searchForGlobalBocc'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BoccListRequest
     */
    'departments'?: Array<string>;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof BoccListRequest
     */
    'pageNumber': number;
    /**
     * 
     * @type {string}
     * @memberof BoccListRequest
     */
    'titre'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BoccListRequest
     */
    'idccs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BoccListRequest
     */
    'sortValue'?: string;
}
/**
 * Résultat d\'une requête pour lister les textes unitaires des bulletins officiels des conventions collectives
 * @export
 * @interface BoccTextsListResponse
 */
export interface BoccTextsListResponse {
    /**
     * 
     * @type {Facet}
     * @memberof BoccTextsListResponse
     */
    'departments'?: Facet;
    /**
     * Nombre total de résultats
     * @type {number}
     * @memberof BoccTextsListResponse
     */
    'totalResultNumber'?: number;
    /**
     * Liste des texts unitaires de la page
     * @type {Array<EsTextBocc>}
     * @memberof BoccTextsListResponse
     */
    'texts'?: Array<EsTextBocc>;
    /**
     * 
     * @type {Facet}
     * @memberof BoccTextsListResponse
     */
    'idccs'?: Facet;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof BoccTextsListResponse
     */
    'executionTime'?: number;
}
/**
 * 
 * @export
 * @interface Bodmr
 */
export interface Bodmr {
    /**
     * Identifiant unique
     * @type {string}
     * @memberof Bodmr
     */
    'id'?: string;
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof Bodmr
     */
    'refInjection'?: string;
    /**
     * 
     * @type {BodmrTexts}
     * @memberof Bodmr
     */
    'texts'?: BodmrTexts;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof Bodmr
     */
    'idTechInjection'?: string;
}
/**
 * 
 * @export
 * @interface BodmrListRequest
 */
export interface BodmrListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof BodmrListRequest
     */
    'pageSize': number;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof BodmrListRequest
     */
    'pageNumber': number;
    /**
     * Ordre de tri
     * @type {string}
     * @memberof BodmrListRequest
     */
    'sort'?: string;
    /**
     * Liste des années à filtrer
     * @type {Array<string>}
     * @memberof BodmrListRequest
     */
    'years'?: Array<string>;
}
/**
 * Résultat d\'une requête pour lister les bulletins officiels des décorations, médailles et récompenses
 * @export
 * @interface BodmrListResponse
 */
export interface BodmrListResponse {
    /**
     * Liste des metadata concernant les pdfs
     * @type {Array<PdfMetadata>}
     * @memberof BodmrListResponse
     */
    'pdfMetadatas'?: Array<PdfMetadata>;
    /**
     * Liste des résultats de la page
     * @type {Array<Bodmr>}
     * @memberof BodmrListResponse
     */
    'results'?: Array<Bodmr>;
    /**
     * Taille du fichier avec son unité
     * @type {string}
     * @memberof BodmrListResponse
     */
    'displaySize'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof BodmrListResponse
     */
    'executionTime'?: number;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof BodmrListResponse
     */
    'totalResultNumber'?: number;
    /**
     * 
     * @type {Facet}
     * @memberof BodmrListResponse
     */
    'years'?: Facet;
}
/**
 * 
 * @export
 * @interface BodmrTexts
 */
export interface BodmrTexts {
    /**
     * 
     * @type {string}
     * @memberof BodmrTexts
     */
    'pathToFile'?: string;
    /**
     * Type du document
     * @type {string}
     * @memberof BodmrTexts
     */
    'typeOfBodmr'?: string;
    /**
     * 
     * @type {string}
     * @memberof BodmrTexts
     */
    'displaySize'?: string;
    /**
     * Numéro du bodmr
     * @type {string}
     * @memberof BodmrTexts
     */
    'number'?: string;
    /**
     * Nom du pdf
     * @type {string}
     * @memberof BodmrTexts
     */
    'pdfName'?: string;
    /**
     * Date de publication du bodmr
     * @type {string}
     * @memberof BodmrTexts
     */
    'dateBodmr'?: string;
}
/**
 * Objet décrivant une recherche dans un champ spécifique
 * @export
 * @interface ChampDTO
 */
export interface ChampDTO {
    /**
     * Opérateur entre les critères de recherche
     * @type {string}
     * @memberof ChampDTO
     */
    'operateur'?: ChampDTOOperateurEnum;
    /**
     * Liste des critères/groupes de critères de recherche pour ce champ
     * @type {Array<CritereDTO>}
     * @memberof ChampDTO
     */
    'criteres'?: Array<CritereDTO>;
    /**
     * Type de champ. Il est possible d\'utiliser la valeur ALL pour rechercher dans tous les champs.
     * @type {string}
     * @memberof ChampDTO
     */
    'typeChamp'?: ChampDTOTypeChampEnum;
}

export const ChampDTOOperateurEnum = {
    Et: 'ET',
    Ou: 'OU'
} as const;

export type ChampDTOOperateurEnum = typeof ChampDTOOperateurEnum[keyof typeof ChampDTOOperateurEnum];
export const ChampDTOTypeChampEnum = {
    All: 'ALL',
    Title: 'TITLE',
    Table: 'TABLE',
    Nor: 'NOR',
    Num: 'NUM',
    AdvancedTexteId: 'ADVANCED_TEXTE_ID',
    NumDelib: 'NUM_DELIB',
    NumDec: 'NUM_DEC',
    NumArticle: 'NUM_ARTICLE',
    Article: 'ARTICLE',
    Ministere: 'MINISTERE',
    Visa: 'VISA',
    Notice: 'NOTICE',
    VisaNotice: 'VISA_NOTICE',
    TravauxPrep: 'TRAVAUX_PREP',
    Signature: 'SIGNATURE',
    Nota: 'NOTA',
    NumAffaire: 'NUM_AFFAIRE',
    Abstrats: 'ABSTRATS',
    Resumes: 'RESUMES',
    Texte: 'TEXTE',
    Ecli: 'ECLI',
    NumLoiDef: 'NUM_LOI_DEF',
    TypeDecision: 'TYPE_DECISION',
    NumeroInterne: 'NUMERO_INTERNE',
    RefPubli: 'REF_PUBLI',
    ResumeCirc: 'RESUME_CIRC',
    TexteRef: 'TEXTE_REF',
    TitreLoiDef: 'TITRE_LOI_DEF',
    RaisonSociale: 'RAISON_SOCIALE',
    MotsCles: 'MOTS_CLES',
    Idcc: 'IDCC'
} as const;

export type ChampDTOTypeChampEnum = typeof ChampDTOTypeChampEnum[keyof typeof ChampDTOTypeChampEnum];

/**
 * requête de consultation de la liste des versions de l\'article de manière chronologique.
 * @export
 * @interface ChronoLegiArticleRequest
 */
export interface ChronoLegiArticleRequest {
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof ChronoLegiArticleRequest
     */
    'textCid': string;
    /**
     * Chronical ID de l\'article
     * @type {string}
     * @memberof ChronoLegiArticleRequest
     */
    'elementCid': string;
}
/**
 * requête de consultation d\'un chronolegi. Le Chronolegi complet du texte est retourné cependant, seulement la période startYear<=>endYear aura le détail des versions chargé.
 * @export
 * @interface ChronoLegiTextRequest
 */
export interface ChronoLegiTextRequest {
    /**
     * Année de fin de chargement des détails
     * @type {number}
     * @memberof ChronoLegiTextRequest
     */
    'endYear': number;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof ChronoLegiTextRequest
     */
    'textCid': string;
    /**
     * Date de référence
     * @type {string}
     * @memberof ChronoLegiTextRequest
     */
    'dateConsult': string;
    /**
     * Année de début de chargement des détails
     * @type {number}
     * @memberof ChronoLegiTextRequest
     */
    'startYear': number;
}
/**
 * Réponse de consultation d\'un chronolegi
 * @export
 * @interface ChronolegiResponse
 */
export interface ChronolegiResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ChronolegiResponse
     */
    'executionTime'?: number;
    /**
     * Liste des regroupements d\'années
     * @type {Array<RegroupementDTO>}
     * @memberof ChronolegiResponse
     */
    'regroupements'?: Array<RegroupementDTO>;
    /**
     * Date de publication
     * @type {string}
     * @memberof ChronolegiResponse
     */
    'datePublication'?: string;
}
/**
 * Objet définissant la cible d\'une modification
 * @export
 * @interface CibleChronoDTO
 */
export interface CibleChronoDTO {
    /**
     * Identifiant unique du parent de l\'élément
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'idParent'?: string;
    /**
     * Identifiant unique de l\'élément
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'id'?: string;
    /**
     * Date de début de l\'élément
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'dateDebut'?: string;
    /**
     * Nature/type du texte
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'nature'?: CibleChronoDTONatureEnum;
    /**
     * Chronical ID du parent de l\'élément
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'cidParent'?: string;
    /**
     * Nom/titre/numéro de l\'élément
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'name'?: string;
    /**
     * Chronical ID de l\'élément
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'cid'?: string;
    /**
     * Chemin représentant l\'arborescence de l\'élément dans le texte
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'path'?: string;
    /**
     * Sens du Lien
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'sens'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'cidText'?: string;
    /**
     * Date de fin de l\'élément
     * @type {string}
     * @memberof CibleChronoDTO
     */
    'dateFin'?: string;
}

export const CibleChronoDTONatureEnum = {
    Loda: 'LODA',
    Jorf: 'JORF',
    Code: 'CODE',
    Kali: 'KALI',
    Jorfcont: 'JORFCONT'
} as const;

export type CibleChronoDTONatureEnum = typeof CibleChronoDTONatureEnum[keyof typeof CibleChronoDTONatureEnum];

/**
 * Objet représentant une circulaire
 * @export
 * @interface Circulaire
 */
export interface Circulaire {
    /**
     * Liste des domaines
     * @type {Array<string>}
     * @memberof Circulaire
     */
    'domaines'?: Array<string>;
    /**
     * Liste des textes de référence
     * @type {Array<TexteReference>}
     * @memberof Circulaire
     */
    'textesReferences'?: Array<TexteReference>;
    /**
     * Identifiant
     * @type {string}
     * @memberof Circulaire
     */
    'id'?: string;
    /**
     * Email déposant
     * @type {string}
     * @memberof Circulaire
     */
    'emailDeposant'?: string;
    /**
     * Auteur
     * @type {string}
     * @memberof Circulaire
     */
    'auteur'?: string;
    /**
     * 
     * @type {string}
     * @memberof Circulaire
     */
    'typeService'?: string;
    /**
     * Numéro interne
     * @type {string}
     * @memberof Circulaire
     */
    'numeroInterne'?: string;
    /**
     * Contenu du fichier en base64
     * @type {string}
     * @memberof Circulaire
     */
    'data'?: string;
    /**
     * Liste des mots clés libres
     * @type {string}
     * @memberof Circulaire
     */
    'motsClesLibres'?: string;
    /**
     * Date d\'export
     * @type {string}
     * @memberof Circulaire
     */
    'dateExport'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof Circulaire
     */
    'origine'?: string;
    /**
     * Date de signature
     * @type {string}
     * @memberof Circulaire
     */
    'dateSignature'?: string;
    /**
     * Chemin vers le fichier PDF
     * @type {string}
     * @memberof Circulaire
     */
    'attachmentUrl'?: string;
    /**
     * Code du ministère déposant
     * @type {number}
     * @memberof Circulaire
     */
    'utilisateurDeposantMinistereCode'?: number;
    /**
     * Etat
     * @type {string}
     * @memberof Circulaire
     */
    'etat'?: string;
    /**
     * Texte HTML des notas
     * @type {string}
     * @memberof Circulaire
     */
    'notaHtml'?: string;
    /**
     * Nota
     * @type {string}
     * @memberof Circulaire
     */
    'nota'?: string;
    /**
     * Référence de publication
     * @type {string}
     * @memberof Circulaire
     */
    'referencePublicationJoBo'?: string;
    /**
     * Date de dépôt
     * @type {string}
     * @memberof Circulaire
     */
    'dateDepot'?: string;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof Circulaire
     */
    'idTechInjection'?: string;
    /**
     * Numéro NOR
     * @type {string}
     * @memberof Circulaire
     */
    'nor'?: string;
    /**
     * Signataire
     * @type {string}
     * @memberof Circulaire
     */
    'signataire'?: string;
    /**
     * Liste des catégories
     * @type {Array<string>}
     * @memberof Circulaire
     */
    'categories'?: Array<string>;
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof Circulaire
     */
    'refInjection'?: string;
    /**
     * Taille du fichier PDF avec son unité
     * @type {string}
     * @memberof Circulaire
     */
    'sizeToDisplay'?: string;
    /**
     * Annexes
     * @type {string}
     * @memberof Circulaire
     */
    'annexes'?: string;
    /**
     * Titre de la circulaire
     * @type {string}
     * @memberof Circulaire
     */
    'titre'?: string;
    /**
     * Résumé
     * @type {string}
     * @memberof Circulaire
     */
    'resume'?: string;
    /**
     * 
     * @type {string}
     * @memberof Circulaire
     */
    'remplace'?: string;
    /**
     * Taille du fichier PDF en octets
     * @type {number}
     * @memberof Circulaire
     */
    'tailleFichierPdf'?: number;
    /**
     * Indique si la circulaire est opposable
     * @type {string}
     * @memberof Circulaire
     */
    'opposable'?: string;
    /**
     * 
     * @type {Attachment}
     * @memberof Circulaire
     */
    'attachment'?: Attachment;
    /**
     * 
     * @type {string}
     * @memberof Circulaire
     */
    'typeGouv'?: string;
    /**
     * Nom du ministère déposant
     * @type {string}
     * @memberof Circulaire
     */
    'utilisateurDeposantMinistere'?: string;
    /**
     * Date de déclaration d\'opposabilité
     * @type {string}
     * @memberof Circulaire
     */
    'dateOpposabilite'?: string;
    /**
     * 
     * @type {string}
     * @memberof Circulaire
     */
    'relevantDate'?: string;
    /**
     * Liste des ministères déposants
     * @type {Array<string>}
     * @memberof Circulaire
     */
    'ministeresDeposants'?: Array<string>;
    /**
     * Date de mise en application
     * @type {string}
     * @memberof Circulaire
     */
    'dateMiseApplication'?: string;
    /**
     * Nom du fichier PDF lié
     * @type {string}
     * @memberof Circulaire
     */
    'attachmentName'?: string;
    /**
     * Liste des mots clés
     * @type {Array<string>}
     * @memberof Circulaire
     */
    'motsCles'?: Array<string>;
    /**
     * Destinataire
     * @type {string}
     * @memberof Circulaire
     */
    'destinataire'?: string;
    /**
     * Numéro CERFA
     * @type {string}
     * @memberof Circulaire
     */
    'numeroCerfa'?: string;
}
/**
 * Requête de consultation d\'une circulaire
 * @export
 * @interface CirculaireConsultRequest
 */
export interface CirculaireConsultRequest {
    /**
     * Identifiant de la circulaire
     * @type {string}
     * @memberof CirculaireConsultRequest
     */
    'id': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof CirculaireConsultRequest
     */
    'searchedString'?: string;
}
/**
 * requête de consultation d\'un texte CNIL
 * @export
 * @interface CnilConsultRequest
 */
export interface CnilConsultRequest {
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof CnilConsultRequest
     */
    'textId': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof CnilConsultRequest
     */
    'searchedString'?: string;
}
/**
 * requête de consultation d\'un texte du fonds CNIL avec ancien ID
 * @export
 * @interface CnilConsultWithAncienId
 */
export interface CnilConsultWithAncienId {
    /**
     * Ancien Id afin de consulter un texte du fond CNIL
     * @type {string}
     * @memberof CnilConsultWithAncienId
     */
    'ancienId'?: string;
}
/**
 * requête de consultation d\'un texte du fonds CODE.
 * @export
 * @interface CodeConsultRequest
 */
export interface CodeConsultRequest {
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof CodeConsultRequest
     */
    'textId': string;
    /**
     * Date de consultation
     * @type {string}
     * @memberof CodeConsultRequest
     */
    'date': string;
    /**
     * Chronical ID de la section a consulter (Non requis pour la consultation de la table des matières sinon obligatoire)
     * @type {string}
     * @memberof CodeConsultRequest
     */
    'sctCid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CodeConsultRequest
     */
    'abrogated'?: boolean;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof CodeConsultRequest
     */
    'searchedString'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CodeConsultRequest
     */
    'fromSuggest'?: boolean;
}
/**
 * requête de consultation d\'un texte du fonds CODE avec ancien ID
 * @export
 * @interface CodeConsultWithAncienId
 */
export interface CodeConsultWithAncienId {
    /**
     * Ancien Id afin de consulter un code
     * @type {string}
     * @memberof CodeConsultWithAncienId
     */
    'ancienId'?: string;
}
/**
 * Requête paginée pour lister les codes
 * @export
 * @interface CodeListRequest
 */
export interface CodeListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof CodeListRequest
     */
    'pageSize': number;
    /**
     * Ordre de tri
     * @type {string}
     * @memberof CodeListRequest
     */
    'sort'?: CodeListRequestSortEnum;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof CodeListRequest
     */
    'pageNumber': number;
    /**
     * Titre de code à chercher
     * @type {string}
     * @memberof CodeListRequest
     */
    'codeName'?: string;
    /**
     * Liste des états juridiques à filtrer
     * @type {Array<string>}
     * @memberof CodeListRequest
     */
    'states'?: Array<CodeListRequestStatesEnum>;
}

export const CodeListRequestSortEnum = {
    TitleAsc: 'TITLE_ASC'
} as const;

export type CodeListRequestSortEnum = typeof CodeListRequestSortEnum[keyof typeof CodeListRequestSortEnum];
export const CodeListRequestStatesEnum = {
    Vigueur: 'VIGUEUR',
    AbrogeDiff: 'ABROGE_DIFF',
    VigueurDiff: 'VIGUEUR_DIFF',
    VigueurEten: 'VIGUEUR_ETEN',
    VigueurNonEten: 'VIGUEUR_NON_ETEN',
    Abroge: 'ABROGE',
    Perime: 'PERIME',
    Annule: 'ANNULE',
    Modifie: 'MODIFIE',
    Disjoint: 'DISJOINT',
    Substitue: 'SUBSTITUE',
    Transfere: 'TRANSFERE',
    Initiale: 'INITIALE',
    ModifieMortNe: 'MODIFIE_MORT_NE',
    SansEtat: 'SANS_ETAT',
    Denonce: 'DENONCE',
    Remplace: 'REMPLACE'
} as const;

export type CodeListRequestStatesEnum = typeof CodeListRequestStatesEnum[keyof typeof CodeListRequestStatesEnum];

/**
 * Résultat d\'une requête paginée pour lister les codes
 * @export
 * @interface CodeListResponse
 */
export interface CodeListResponse {
    /**
     * 
     * @type {Facet}
     * @memberof CodeListResponse
     */
    'codeNames'?: Facet;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof CodeListResponse
     */
    'totalResultNumber'?: number;
    /**
     * Liste des résultats de la page
     * @type {Array<CodeListResult>}
     * @memberof CodeListResponse
     */
    'results'?: Array<CodeListResult>;
    /**
     * 
     * @type {Facet}
     * @memberof CodeListResponse
     */
    'states'?: Facet;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof CodeListResponse
     */
    'executionTime'?: number;
}
/**
 * Objet représentant un résultat de code
 * @export
 * @interface CodeListResult
 */
export interface CodeListResult {
    /**
     * Identifiant unique
     * @type {string}
     * @memberof CodeListResult
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeListResult
     */
    'pdfFilePath'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof CodeListResult
     */
    'dateDebut'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeListResult
     */
    'pdfFileName'?: string;
    /**
     * Dernière date de mise à jour
     * @type {string}
     * @memberof CodeListResult
     */
    'lastUpdate'?: string;
    /**
     * Chronical ID
     * @type {string}
     * @memberof CodeListResult
     */
    'cid'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof CodeListResult
     */
    'etat'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeListResult
     */
    'pdfFileSize'?: string;
    /**
     * Titre du code
     * @type {string}
     * @memberof CodeListResult
     */
    'titre'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof CodeListResult
     */
    'dateFin'?: string;
}
/**
 * requête de récupération des liens de concordance d\'un article
 * @export
 * @interface ConcordanceLinksRequest
 */
export interface ConcordanceLinksRequest {
    /**
     * Identifiant de l\'article
     * @type {string}
     * @memberof ConcordanceLinksRequest
     */
    'articleId': string;
}
/**
 * Réponse à une requête de consultation d\'un accord d\'entreprise
 * @export
 * @interface ConsultAccoResponse
 */
export interface ConsultAccoResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultAccoResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {Accord}
     * @memberof ConsultAccoResponse
     */
    'acco'?: Accord;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultAccoResponse
     */
    'dereferenced'?: boolean;
}
/**
 * Objet représentant un article lors d\'une consultation
 * @export
 * @interface ConsultArticle
 */
export interface ConsultArticle {
    /**
     * Titre des sections du chemin de l\'article
     * @type {Array<string>}
     * @memberof ConsultArticle
     */
    'pathTitle'?: Array<string>;
    /**
     * Date de modification par l\'élément modificateur
     * @type {string}
     * @memberof ConsultArticle
     */
    'modificatorDate'?: string;
    /**
     * Historique
     * @type {string}
     * @memberof ConsultArticle
     */
    'historique'?: string;
    /**
     * Identifiant
     * @type {string}
     * @memberof ConsultArticle
     */
    'id'?: string;
    /**
     * Numéro indiquant l\'ordre d\'affichage
     * @type {number}
     * @memberof ConsultArticle
     */
    'intOrdre'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsultArticle
     */
    'versionLabel'?: string;
    /**
     * Date de fin de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'dateFin'?: string;
    /**
     * Liste de nota section à afficher
     * @type {Array<string>}
     * @memberof ConsultArticle
     */
    'notaSectionsAafficher'?: Array<string>;
    /**
     * Condition differée
     * @type {string}
     * @memberof ConsultArticle
     */
    'conditionDiffere'?: string;
    /**
     * Version de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'articleVersion'?: string;
    /**
     * Texte HTML des informations restructuration de branche
     * @type {string}
     * @memberof ConsultArticle
     */
    'infosRestructurationBrancheHtml'?: string;
    /**
     * Chronical ID de l\'élément modificateur de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'modificatorCid'?: string;
    /**
     * Date de début de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'dateDebut'?: string;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultArticle
     */
    'dereferenced'?: boolean;
    /**
     * Texte HTML des informations complémentaires
     * @type {string}
     * @memberof ConsultArticle
     */
    'infosComplementairesHtml'?: string;
    /**
     * Informations complémentaires
     * @type {string}
     * @memberof ConsultArticle
     */
    'infosComplementaires'?: string;
    /**
     * Contenu HTML de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'content'?: string;
    /**
     * Type
     * @type {string}
     * @memberof ConsultArticle
     */
    'type'?: string;
    /**
     * Liste des liens de citation. Toujours vide (voir propriété comporteLiens)
     * @type {Array<LienCitation>}
     * @memberof ConsultArticle
     */
    'lstLienCitation'?: Array<LienCitation>;
    /**
     * 
     * @type {string}
     * @memberof ConsultArticle
     */
    'renvoi'?: string;
    /**
     * Titre de l\'élément modificateur de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'modificatorTitle'?: string;
    /**
     * Chemin de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'path'?: string;
    /**
     * Numéro de l\'article
     * @type {string}
     * @memberof ConsultArticle
     */
    'num'?: string;
    /**
     * Liste des liens de modification
     * @type {Array<LienModification>}
     * @memberof ConsultArticle
     */
    'lstLienModification'?: Array<LienModification>;
    /**
     * Nota
     * @type {string}
     * @memberof ConsultArticle
     */
    'nota'?: string;
    /**
     * Surtitre
     * @type {string}
     * @memberof ConsultArticle
     */
    'surtitre'?: string;
    /**
     * Indique si l\'article contient des liens de citation. Utiliser l\'API relatedLinksArticle pour récupérer la liste des liens.
     * @type {boolean}
     * @memberof ConsultArticle
     */
    'comporteLiens'?: boolean;
    /**
     * Chronical ID
     * @type {string}
     * @memberof ConsultArticle
     */
    'cid'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultArticle
     */
    'executionTime'?: number;
    /**
     * Informations restructuration de branche
     * @type {string}
     * @memberof ConsultArticle
     */
    'infosRestructurationBranche'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof ConsultArticle
     */
    'etat'?: string;
}
/**
 * 
 * @export
 * @interface ConsultBoccResponse
 */
export interface ConsultBoccResponse {
    /**
     * 
     * @type {string}
     * @memberof ConsultBoccResponse
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultBoccResponse
     */
    'pathToFile'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConsultBoccResponse
     */
    'forGlobalBocc'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConsultBoccResponse
     */
    'title'?: string;
    /**
     * 
     * @type {EsParutionBocc}
     * @memberof ConsultBoccResponse
     */
    'bocc'?: EsParutionBocc;
    /**
     * 
     * @type {string}
     * @memberof ConsultBoccResponse
     */
    'displaySize'?: string;
    /**
     * Date de parution
     * @type {string}
     * @memberof ConsultBoccResponse
     */
    'dateParution'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultBoccResponse
     */
    'numParution'?: string;
}
/**
 * Réponse à une requête de consultation d\'une circulaire
 * @export
 * @interface ConsultCirculaireResponse
 */
export interface ConsultCirculaireResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultCirculaireResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {Circulaire}
     * @memberof ConsultCirculaireResponse
     */
    'circulaire'?: Circulaire;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultCirculaireResponse
     */
    'dereferenced'?: boolean;
}
/**
 * réponse de consultation d\'un texte CNIL
 * @export
 * @interface ConsultCnilTextResponse
 */
export interface ConsultCnilTextResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultCnilTextResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {TexteSimple}
     * @memberof ConsultCnilTextResponse
     */
    'text'?: TexteSimple;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultCnilTextResponse
     */
    'dereferenced'?: boolean;
}
/**
 * Objet date permettant la recherche
 * @export
 * @interface ConsultDateRequest
 */
export interface ConsultDateRequest {
    /**
     * Année
     * @type {number}
     * @memberof ConsultDateRequest
     */
    'year'?: number;
    /**
     * Jour
     * @type {number}
     * @memberof ConsultDateRequest
     */
    'dayOfMonth'?: number;
    /**
     * Mois
     * @type {number}
     * @memberof ConsultDateRequest
     */
    'month'?: number;
}
/**
 * Réponse à une requête de consultation d\'un débat parlementaire
 * @export
 * @interface ConsultDebatResponse
 */
export interface ConsultDebatResponse {
    /**
     * 
     * @type {Debat}
     * @memberof ConsultDebatResponse
     */
    'debat'?: Debat;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultDebatResponse
     */
    'executionTime'?: number;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultDebatResponse
     */
    'dereferenced'?: boolean;
}
/**
 * Réponse à une requête de consultation d\'un dossier législatif
 * @export
 * @interface ConsultDossierLegislatifResponse
 */
export interface ConsultDossierLegislatifResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultDossierLegislatifResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {DossierLegislatif}
     * @memberof ConsultDossierLegislatifResponse
     */
    'dossierLegislatif'?: DossierLegislatif;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultDossierLegislatifResponse
     */
    'dereferenced'?: boolean;
}
/**
 * Réponse à une requête de consultation d\'un texte JORF
 * @export
 * @interface ConsultJorfResponse
 */
export interface ConsultJorfResponse {
    /**
     * Liste des sections de premier niveau du texte. La liste est ordonnée
     * @type {Array<ConsultSection>}
     * @memberof ConsultJorfResponse
     */
    'sections'?: Array<ConsultSection>;
    /**
     * Appellations
     * @type {Array<string>}
     * @memberof ConsultJorfResponse
     */
    'appellations'?: Array<string>;
    /**
     * Travaux préparatoires
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'prepWork'?: string;
    /**
     * Date de fin de la version
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'dateFinVersion'?: string;
    /**
     * Etat juridique du texte
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'jurisState'?: string;
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'id'?: string;
    /**
     * Notice
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'notice'?: string;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultJorfResponse
     */
    'dereferenced'?: boolean;
    /**
     * Date d\'état juridique
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'jurisDate'?: string;
    /**
     * Date de parution
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'dateParution'?: string;
    /**
     * INAP
     * @type {boolean}
     * @memberof ConsultJorfResponse
     */
    'inap'?: boolean;
    /**
     * Identifiant du conteneur du texte lorsqu\'il en existe un.
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'idConteneur'?: string;
    /**
     * Liste des articles racine du texte. La liste est ordonnée
     * @type {Array<ConsultArticle>}
     * @memberof ConsultJorfResponse
     */
    'articles'?: Array<ConsultArticle>;
    /**
     * Liste des métadonnées des fichiers attachés au document
     * @type {Array<FileMetadata>}
     * @memberof ConsultJorfResponse
     */
    'jorfFileMetadata'?: Array<FileMetadata>;
    /**
     * 
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'fileSize'?: string;
    /**
     * Titre du texte
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'title'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'nature'?: string;
    /**
     * Titre du texte correspondant
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'jorfText'?: string;
    /**
     * Date de début de la version
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'dateDebutVersion'?: string;
    /**
     * Observations
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'observations'?: string;
    /**
     * Rectificatif
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'rectificatif'?: string;
    /**
     * Etat du texte
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'etat'?: string;
    /**
     * Numéro NOR
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'nor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'fileName'?: string;
    /**
     * Visas
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'visa'?: string;
    /**
     * Numéro de texte
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'textNumber'?: string;
    /**
     * Nota
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'nota'?: string;
    /**
     * Alias
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'alias'?: string;
    /**
     * Résumé
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'resume'?: string;
    /**
     * identifiant européen de la ‎législation ou European Legislation Identifier
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'eli'?: string;
    /**
     * Numéro de parution
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'numParution'?: string;
    /**
     * Date de signature
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'dateTexte'?: string;
    /**
     * Le numéro de la page de l\'article dans le journal officiel
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'pagePdf'?: string;
    /**
     * Date de modification
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'modifDate'?: string;
    /**
     * Indique si le texte est abrogé
     * @type {boolean}
     * @memberof ConsultJorfResponse
     */
    'textAbroge'?: boolean;
    /**
     * Signataires
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'signers'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'cid'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultJorfResponse
     */
    'executionTime'?: number;
    /**
     * Mots-clés
     * @type {Array<string>}
     * @memberof ConsultJorfResponse
     */
    'motsCles'?: Array<string>;
    /**
     * Liens
     * @type {Array<TexteLien>}
     * @memberof ConsultJorfResponse
     */
    'liens'?: Array<TexteLien>;
    /**
     * 
     * @type {string}
     * @memberof ConsultJorfResponse
     */
    'filePath'?: string;
    /**
     * Liste des dossiers legislatifs
     * @type {Array<DossierLegislatif>}
     * @memberof ConsultJorfResponse
     */
    'dossiersLegislatifs'?: Array<DossierLegislatif>;
}
/**
 * réponse de consultation d\'un texte de Jurisprudence judiciaire
 * @export
 * @interface ConsultJuriTextResponse
 */
export interface ConsultJuriTextResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultJuriTextResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {TexteSimple}
     * @memberof ConsultJuriTextResponse
     */
    'text'?: TexteSimple;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultJuriTextResponse
     */
    'dereferenced'?: boolean;
}
/**
 * Réponse à une requête de consultation d\'une convention collective
 * @export
 * @interface ConsultKaliContResponse
 */
export interface ConsultKaliContResponse {
    /**
     * Liste des identifiants des textes de base
     * @type {Array<string>}
     * @memberof ConsultKaliContResponse
     */
    'texteBaseId'?: Array<string>;
    /**
     * Identifiant
     * @type {string}
     * @memberof ConsultKaliContResponse
     */
    'id'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof ConsultKaliContResponse
     */
    'titre'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof ConsultKaliContResponse
     */
    'nature'?: string;
    /**
     * Texte HTML de la description de fusion
     * @type {string}
     * @memberof ConsultKaliContResponse
     */
    'descriptionFusionHtml'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultKaliContResponse
     */
    'executionTime'?: number;
    /**
     * numéro du texte
     * @type {string}
     * @memberof ConsultKaliContResponse
     */
    'numeroTexte'?: string;
    /**
     * Numéro
     * @type {string}
     * @memberof ConsultKaliContResponse
     */
    'num'?: string;
    /**
     * Liste des catégories
     * @type {Array<string>}
     * @memberof ConsultKaliContResponse
     */
    'categorisation'?: Array<string>;
    /**
     * Liste des conventions collectives
     * @type {Array<ConsultSection>}
     * @memberof ConsultKaliContResponse
     */
    'sections'?: Array<ConsultSection>;
    /**
     * Liste des activités professionelles
     * @type {Array<string>}
     * @memberof ConsultKaliContResponse
     */
    'activitePro'?: Array<string>;
}
/**
 * Réponse à une requête de consultation d\'un texte d\'une convention collective
 * @export
 * @interface ConsultKaliTextResponse
 */
export interface ConsultKaliTextResponse {
    /**
     * Date de fin de la version
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'dateFinVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'versionLabel'?: string;
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'id'?: string;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultKaliTextResponse
     */
    'dereferenced'?: boolean;
    /**
     * Notice
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'notice'?: string;
    /**
     * INAP
     * @type {boolean}
     * @memberof ConsultKaliTextResponse
     */
    'inap'?: boolean;
    /**
     * 
     * @type {SignataireKali}
     * @memberof ConsultKaliTextResponse
     */
    'signataires'?: SignataireKali;
    /**
     * Identifiant du conteneur du texte lorsqu\'il en existe un.
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'idConteneur'?: string;
    /**
     * Condition différée
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'conditionDiffere'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'fileSize'?: string;
    /**
     * Titre du texte
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'title'?: string;
    /**
     * Etat juridique du texte
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'jurisState'?: string;
    /**
     * Description fusion
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'descriptionFusionHtml'?: string;
    /**
     * Visas
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'visa'?: string;
    /**
     * Numéro de texte
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'textNumber'?: string;
    /**
     * Nota
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'nota'?: string;
    /**
     * Alias
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'alias'?: string;
    /**
     * Visas
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'visas'?: string;
    /**
     * Date de modification
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'modifDate'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'cid'?: string;
    /**
     * Etat du texte
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'etat'?: string;
    /**
     * Liste des mots clés
     * @type {Array<string>}
     * @memberof ConsultKaliTextResponse
     */
    'motsCles'?: Array<string>;
    /**
     * Liens
     * @type {Array<TexteLien>}
     * @memberof ConsultKaliTextResponse
     */
    'liens'?: Array<TexteLien>;
    /**
     * Liste des codes de nomenclature
     * @type {Array<string>}
     * @memberof ConsultKaliTextResponse
     */
    'codesNomenclature'?: Array<string>;
    /**
     * Appellations
     * @type {Array<string>}
     * @memberof ConsultKaliTextResponse
     */
    'appellations'?: Array<string>;
    /**
     * Travaux préparatoires
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'prepWork'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'fileName'?: string;
    /**
     * Numéro Bulletin Officiel
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'numeroBo'?: string;
    /**
     * Texte HTML des visas
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'visasHtml'?: string;
    /**
     * Date d\'état juridique
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'jurisDate'?: string;
    /**
     * Date de parution
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'dateParution'?: string;
    /**
     * Liste des articles racine du texte. La liste est ordonnée
     * @type {Array<ConsultArticle>}
     * @memberof ConsultKaliTextResponse
     */
    'articles'?: Array<ConsultArticle>;
    /**
     * Texte HTML des informations restructuration de branche
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'infosRestructurationBrancheHtml'?: string;
    /**
     * Type de texte
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'typeTexte'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'nature'?: string;
    /**
     * Titre du texte correspondant
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'jorfText'?: string;
    /**
     * Date de début de la version
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'dateDebutVersion'?: string;
    /**
     * Texte HTML des informations complémentaires
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'infosComplementairesHtml'?: string;
    /**
     * Rectificatif
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'rectificatif'?: string;
    /**
     * Numéro NOR
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'nor'?: string;
    /**
     * Observations
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'observations'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'libelleElargissement'?: string;
    /**
     * Numero renvoi
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'renvoi'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'filePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'libelleExtension'?: string;
    /**
     * Résumé
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'resume'?: string;
    /**
     * identifiant européen de la ‎législation ou European Legislation Identifier
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'eli'?: string;
    /**
     * Numéro de parution
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'numParution'?: string;
    /**
     * Date de signature
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'dateTexte'?: string;
    /**
     * Le numéro de la page de l\'article dans le journal officiel
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'pagePdf'?: string;
    /**
     * Liste des conteneurs du texte
     * @type {Array<Conteneur>}
     * @memberof ConsultKaliTextResponse
     */
    'conteneurs'?: Array<Conteneur>;
    /**
     * Indique si le texte est abrogé
     * @type {boolean}
     * @memberof ConsultKaliTextResponse
     */
    'textAbroge'?: boolean;
    /**
     * Signataires
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'signers'?: string;
    /**
     * Origine de la publication
     * @type {string}
     * @memberof ConsultKaliTextResponse
     */
    'originePubli'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultKaliTextResponse
     */
    'executionTime'?: number;
    /**
     * Liste des sections de premier niveau du texte. La liste est ordonnée
     * @type {Array<ConsultSection>}
     * @memberof ConsultKaliTextResponse
     */
    'sections'?: Array<ConsultSection>;
    /**
     * Liste des dossiers legislatifs
     * @type {Array<DossierLegislatif>}
     * @memberof ConsultKaliTextResponse
     */
    'dossiersLegislatifs'?: Array<DossierLegislatif>;
}
/**
 * Objet représentant une section lors d\'une consultation
 * @export
 * @interface ConsultSection
 */
export interface ConsultSection {
    /**
     * Titre de la section
     * @type {string}
     * @memberof ConsultSection
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultSection
     */
    'renvoi'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultSection
     */
    'renvoiNum'?: string;
    /**
     * Identifiant
     * @type {string}
     * @memberof ConsultSection
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultSection
     */
    'commentaire'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultSection
     */
    'notaHtml'?: string;
    /**
     * Numéro indiquant l\'ordre d\'affichage
     * @type {number}
     * @memberof ConsultSection
     */
    'intOrdre'?: number;
    /**
     * Indique si la section est celle demandée en consultation
     * @type {boolean}
     * @memberof ConsultSection
     */
    'sectionConsultee'?: boolean;
    /**
     * Date de fin de la version de la section
     * @type {string}
     * @memberof ConsultSection
     */
    'dateFin'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConsultSection
     */
    'notaSectionsAafficher'?: Array<string>;
    /**
     * Liste des articles enfants de la section. La liste est ordonnée
     * @type {Array<ConsultArticle>}
     * @memberof ConsultSection
     */
    'articles'?: Array<ConsultArticle>;
    /**
     * Date de début de la version de la section
     * @type {string}
     * @memberof ConsultSection
     */
    'dateDebut'?: string;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultSection
     */
    'dereferenced'?: boolean;
    /**
     * Chronical ID
     * @type {string}
     * @memberof ConsultSection
     */
    'cid'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultSection
     */
    'executionTime'?: number;
    /**
     * Date de dernière modification
     * @type {string}
     * @memberof ConsultSection
     */
    'dateModif'?: string;
    /**
     * Liste des sections enfants de la section (peut être un texte dans le cas des conventions collectives). La liste est ordonnée
     * @type {Array<ConsultSection>}
     * @memberof ConsultSection
     */
    'sections'?: Array<ConsultSection>;
    /**
     * Etat juridique
     * @type {string}
     * @memberof ConsultSection
     */
    'etat'?: string;
}
/**
 * Réponse à une requête de consultation d\'un texte
 * @export
 * @interface ConsultTextResponse
 */
export interface ConsultTextResponse {
    /**
     * Liste des sections de premier niveau du texte. La liste est ordonnée
     * @type {Array<ConsultSection>}
     * @memberof ConsultTextResponse
     */
    'sections'?: Array<ConsultSection>;
    /**
     * Appellations
     * @type {Array<string>}
     * @memberof ConsultTextResponse
     */
    'appellations'?: Array<string>;
    /**
     * Travaux préparatoires
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'prepWork'?: string;
    /**
     * Date de fin de la version
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'dateFinVersion'?: string;
    /**
     * Etat juridique du texte
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'jurisState'?: string;
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'id'?: string;
    /**
     * Notice
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'notice'?: string;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof ConsultTextResponse
     */
    'dereferenced'?: boolean;
    /**
     * Date d\'état juridique
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'jurisDate'?: string;
    /**
     * Date de parution
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'dateParution'?: string;
    /**
     * INAP
     * @type {boolean}
     * @memberof ConsultTextResponse
     */
    'inap'?: boolean;
    /**
     * Identifiant du conteneur du texte lorsqu\'il en existe un.
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'idConteneur'?: string;
    /**
     * Liste des articles racine du texte. La liste est ordonnée
     * @type {Array<ConsultArticle>}
     * @memberof ConsultTextResponse
     */
    'articles'?: Array<ConsultArticle>;
    /**
     * Titre du texte
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'fileSize'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'nature'?: string;
    /**
     * Titre du texte correspondant
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'jorfText'?: string;
    /**
     * Date de début de la version
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'dateDebutVersion'?: string;
    /**
     * Observations
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'observations'?: string;
    /**
     * Rectificatif
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'rectificatif'?: string;
    /**
     * Etat du texte
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'etat'?: string;
    /**
     * Numéro NOR
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'nor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'fileName'?: string;
    /**
     * Visas
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'visa'?: string;
    /**
     * Numéro de texte
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'textNumber'?: string;
    /**
     * Nota
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'nota'?: string;
    /**
     * Alias
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'alias'?: string;
    /**
     * Résumé
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'resume'?: string;
    /**
     * identifiant européen de la ‎législation ou European Legislation Identifier
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'eli'?: string;
    /**
     * Numéro de parution
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'numParution'?: string;
    /**
     * Date de signature
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'dateTexte'?: string;
    /**
     * Le numéro de la page de l\'article dans le journal officiel
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'pagePdf'?: string;
    /**
     * Date de modification
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'modifDate'?: string;
    /**
     * Indique si le texte est abrogé
     * @type {boolean}
     * @memberof ConsultTextResponse
     */
    'textAbroge'?: boolean;
    /**
     * Signataires
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'signers'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'cid'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConsultTextResponse
     */
    'executionTime'?: number;
    /**
     * Mots-clés
     * @type {Array<string>}
     * @memberof ConsultTextResponse
     */
    'motsCles'?: Array<string>;
    /**
     * Liens
     * @type {Array<TexteLien>}
     * @memberof ConsultTextResponse
     */
    'liens'?: Array<TexteLien>;
    /**
     * 
     * @type {string}
     * @memberof ConsultTextResponse
     */
    'filePath'?: string;
    /**
     * Liste des dossiers legislatifs
     * @type {Array<DossierLegislatif>}
     * @memberof ConsultTextResponse
     */
    'dossiersLegislatifs'?: Array<DossierLegislatif>;
}
/**
 * Objet représentant un conteneur
 * @export
 * @interface Conteneur
 */
export interface Conteneur {
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof Conteneur
     */
    'refInjection'?: string;
    /**
     * Identifiant du conteneur
     * @type {string}
     * @memberof Conteneur
     */
    'id'?: string;
    /**
     * Numéro
     * @type {string}
     * @memberof Conteneur
     */
    'num'?: string;
    /**
     * Titre du conteneur
     * @type {string}
     * @memberof Conteneur
     */
    'titre'?: string;
    /**
     * chemin vers le conteneur
     * @type {string}
     * @memberof Conteneur
     */
    'url'?: string;
    /**
     * Identifiant ELI
     * @type {string}
     * @memberof Conteneur
     */
    'idEli'?: string;
    /**
     * Chronical ID
     * @type {string}
     * @memberof Conteneur
     */
    'cid'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof Conteneur
     */
    'origine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Conteneur
     */
    'relevantDate'?: string;
    /**
     * Nature du conteneur
     * @type {string}
     * @memberof Conteneur
     */
    'nature'?: string;
    /**
     * Date de publication
     * @type {string}
     * @memberof Conteneur
     */
    'datePubli'?: string;
    /**
     * Numéro conteneur
     * @type {string}
     * @memberof Conteneur
     */
    'numero'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof Conteneur
     */
    'etat'?: string;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof Conteneur
     */
    'idTechInjection'?: string;
    /**
     * Ancien Identifiant
     * @type {string}
     * @memberof Conteneur
     */
    'ancienId'?: string;
}
/**
 * Objet représentant le contexte d\'un élément
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * Liste des versions de titres pour le texte parent
     * @type {Array<DetailContext>}
     * @memberof Context
     */
    'titreTxt'?: Array<DetailContext>;
    /**
     * Nombre de versions existantes pour le parent
     * @type {number}
     * @memberof Context
     */
    'nombreVersionParent'?: number;
    /**
     * Liste des sections parentes de l\'élément
     * @type {Array<DetailContext>}
     * @memberof Context
     */
    'titresTM'?: Array<DetailContext>;
    /**
     * Longueur du chemin
     * @type {number}
     * @memberof Context
     */
    'longeurChemin'?: number;
}
/**
 * Requête paginée pour lister les conventions collectives
 * @export
 * @interface ConventionsListRequest
 */
export interface ConventionsListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof ConventionsListRequest
     */
    'pageSize': number;
    /**
     * Liste des états juridique à filtrer
     * @type {Array<string>}
     * @memberof ConventionsListRequest
     */
    'legalStatus'?: Array<ConventionsListRequestLegalStatusEnum>;
    /**
     * Texte à rechercher dans les titres permettant de filtrer le résultat
     * @type {string}
     * @memberof ConventionsListRequest
     */
    'titre'?: string;
    /**
     * Ordre de tri
     * @type {string}
     * @memberof ConventionsListRequest
     */
    'sort'?: ConventionsListRequestSortEnum;
    /**
     * Ordre de tri
     * @type {string}
     * @memberof ConventionsListRequest
     */
    'secondSort'?: ConventionsListRequestSecondSortEnum;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof ConventionsListRequest
     */
    'pageNumber': number;
    /**
     * IDCC permettant de filtrer le résultat
     * @type {string}
     * @memberof ConventionsListRequest
     */
    'idcc'?: string;
    /**
     * Liste des mots clés à filtrer
     * @type {Array<string>}
     * @memberof ConventionsListRequest
     */
    'keyWords'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConventionsListRequest
     */
    'textesBase'?: Array<ConventionsListRequestTextesBaseEnum>;
}

export const ConventionsListRequestLegalStatusEnum = {
    Vigueur: 'VIGUEUR',
    AbrogeDiff: 'ABROGE_DIFF',
    VigueurDiff: 'VIGUEUR_DIFF',
    VigueurEten: 'VIGUEUR_ETEN',
    VigueurNonEten: 'VIGUEUR_NON_ETEN',
    Abroge: 'ABROGE',
    Perime: 'PERIME',
    Annule: 'ANNULE',
    Modifie: 'MODIFIE',
    Disjoint: 'DISJOINT',
    Substitue: 'SUBSTITUE',
    Transfere: 'TRANSFERE',
    Initiale: 'INITIALE',
    ModifieMortNe: 'MODIFIE_MORT_NE',
    SansEtat: 'SANS_ETAT',
    Denonce: 'DENONCE',
    Remplace: 'REMPLACE'
} as const;

export type ConventionsListRequestLegalStatusEnum = typeof ConventionsListRequestLegalStatusEnum[keyof typeof ConventionsListRequestLegalStatusEnum];
export const ConventionsListRequestSortEnum = {
    DateUpdate: 'DATE_UPDATE',
    DatePubliAsc: 'DATE_PUBLI_ASC',
    DatePubliDesc: 'DATE_PUBLI_DESC',
    SignatureDateAsc: 'SIGNATURE_DATE_ASC',
    SignatureDateDesc: 'SIGNATURE_DATE_DESC',
    IdDesc: 'ID_DESC',
    IdAsc: 'ID_ASC'
} as const;

export type ConventionsListRequestSortEnum = typeof ConventionsListRequestSortEnum[keyof typeof ConventionsListRequestSortEnum];
export const ConventionsListRequestSecondSortEnum = {
    DateUpdate: 'DATE_UPDATE',
    DatePubliAsc: 'DATE_PUBLI_ASC',
    DatePubliDesc: 'DATE_PUBLI_DESC',
    SignatureDateAsc: 'SIGNATURE_DATE_ASC',
    SignatureDateDesc: 'SIGNATURE_DATE_DESC',
    IdDesc: 'ID_DESC',
    IdAsc: 'ID_ASC'
} as const;

export type ConventionsListRequestSecondSortEnum = typeof ConventionsListRequestSecondSortEnum[keyof typeof ConventionsListRequestSecondSortEnum];
export const ConventionsListRequestTextesBaseEnum = {
    TexteBase: 'TEXTE_BASE'
} as const;

export type ConventionsListRequestTextesBaseEnum = typeof ConventionsListRequestTextesBaseEnum[keyof typeof ConventionsListRequestTextesBaseEnum];

/**
 * Résultat d\'une requête paginée pour lister les textes des conventions collectives
 * @export
 * @interface ConventionsListResponse
 */
export interface ConventionsListResponse {
    /**
     * 
     * @type {Facet}
     * @memberof ConventionsListResponse
     */
    'moteCles'?: Facet;
    /**
     * 
     * @type {Facet}
     * @memberof ConventionsListResponse
     */
    'legalStatus'?: Facet;
    /**
     * Liste des résultats de la page
     * @type {Array<ConventionsListResult>}
     * @memberof ConventionsListResponse
     */
    'results'?: Array<ConventionsListResult>;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof ConventionsListResponse
     */
    'executionTime'?: number;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof ConventionsListResponse
     */
    'totalResultNumber'?: number;
    /**
     * 
     * @type {Facet}
     * @memberof ConventionsListResponse
     */
    'typeTexte'?: Facet;
}
/**
 * Objet représentant un résultat de texte de convention collective
 * @export
 * @interface ConventionsListResult
 */
export interface ConventionsListResult {
    /**
     * Description de fusion
     * @type {string}
     * @memberof ConventionsListResult
     */
    'descriptionFusion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConventionsListResult
     */
    'pdfFilePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConventionsListResult
     */
    'pdfFileName'?: string;
    /**
     * IDCC
     * @type {string}
     * @memberof ConventionsListResult
     */
    'idcc'?: string;
    /**
     * Chronical ID
     * @type {string}
     * @memberof ConventionsListResult
     */
    'cid'?: string;
    /**
     * Etat juridique du texte
     * @type {string}
     * @memberof ConventionsListResult
     */
    'etat'?: string;
    /**
     * Identifiant unique
     * @type {string}
     * @memberof ConventionsListResult
     */
    'id'?: string;
    /**
     * Texte HTML de la description de fusion
     * @type {string}
     * @memberof ConventionsListResult
     */
    'descriptionFusionHtml'?: string;
    /**
     * Chronical ID du conteneur
     * @type {string}
     * @memberof ConventionsListResult
     */
    'cidConteneur'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof ConventionsListResult
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConventionsListResult
     */
    'pdfFileSize'?: string;
}
/**
 * Objet décrivant un critère ou un groupe de critères
 * @export
 * @interface CritereDTO
 */
export interface CritereDTO {
    /**
     * Opérateur entre les sous-critères
     * @type {string}
     * @memberof CritereDTO
     */
    'operateur': CritereDTOOperateurEnum;
    /**
     * Sous-critère/Sous-groupe de critères
     * @type {Array<CritereDTO>}
     * @memberof CritereDTO
     */
    'criteres'?: Array<CritereDTO>;
    /**
     * Mot(s)/expression recherchés
     * @type {string}
     * @memberof CritereDTO
     */
    'valeur': string;
    /**
     * Proximité maximum entre les mots du champ valeur. La proximité représente la distance maximale, en mots, entre deux termes recherchés.
     * @type {number}
     * @memberof CritereDTO
     */
    'proximite'?: number;
    /**
     * Type de recherche effectuée
     * @type {string}
     * @memberof CritereDTO
     */
    'typeRecherche': CritereDTOTypeRechercheEnum;
}

export const CritereDTOOperateurEnum = {
    Et: 'ET',
    Ou: 'OU'
} as const;

export type CritereDTOOperateurEnum = typeof CritereDTOOperateurEnum[keyof typeof CritereDTOOperateurEnum];
export const CritereDTOTypeRechercheEnum = {
    UnDesMots: 'UN_DES_MOTS',
    Exacte: 'EXACTE',
    TousLesMotsDansUnChamp: 'TOUS_LES_MOTS_DANS_UN_CHAMP',
    AucunDesMots: 'AUCUN_DES_MOTS',
    AucuneCorrespondanceACetteExpression: 'AUCUNE_CORRESPONDANCE_A_CETTE_EXPRESSION'
} as const;

export type CritereDTOTypeRechercheEnum = typeof CritereDTOTypeRechercheEnum[keyof typeof CritereDTOTypeRechercheEnum];

/**
 * Objet représentant une période de recherche
 * @export
 * @interface DatePeriod
 */
export interface DatePeriod {
    /**
     * Date de fin
     * @type {string}
     * @memberof DatePeriod
     */
    'end'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof DatePeriod
     */
    'start'?: string;
}
/**
 * Résultat d\'une requête pour récupérer les dates pour lesquelles il n\'y a pas eu de publication du Journal officiel
 * @export
 * @interface DatesWithNoJoResponse
 */
export interface DatesWithNoJoResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof DatesWithNoJoResponse
     */
    'executionTime'?: number;
    /**
     * Liste des dates
     * @type {Array<string>}
     * @memberof DatesWithNoJoResponse
     */
    'lstDateDisabled'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Debat
 */
export interface Debat {
    /**
     * 
     * @type {number}
     * @memberof Debat
     */
    'legislature'?: number;
    /**
     * 
     * @type {number}
     * @memberof Debat
     */
    'numeroParution'?: number;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'nomSession'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'session'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'dateParution'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'attachmentUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Debat
     */
    'anneeParution'?: number;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'idEli'?: string;
    /**
     * 
     * @type {Attachment}
     * @memberof Debat
     */
    'attachment'?: Attachment;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'origine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'pathToFile'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'refInjection'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'displaySize'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'typeAssemblee'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'dateSeance'?: string;
    /**
     * 
     * @type {string}
     * @memberof Debat
     */
    'idTechInjection'?: string;
}
/**
 * Requête de consultation d\'un débat parlementaire
 * @export
 * @interface DebatParlementaireConsultRequest
 */
export interface DebatParlementaireConsultRequest {
    /**
     * Identifiant du débat parlementaire
     * @type {string}
     * @memberof DebatParlementaireConsultRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DebatsParlementairesListRequest
 */
export interface DebatsParlementairesListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof DebatsParlementairesListRequest
     */
    'pageSize': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DebatsParlementairesListRequest
     */
    'typesPublication'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DebatsParlementairesListRequest
     */
    'secondSortValue'?: string;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof DebatsParlementairesListRequest
     */
    'pageNumber': number;
    /**
     * 
     * @type {string}
     * @memberof DebatsParlementairesListRequest
     */
    'dateParution'?: string;
    /**
     * 
     * @type {string}
     * @memberof DebatsParlementairesListRequest
     */
    'sortValue'?: string;
}
/**
 * Résultat d\'une requête pour lister les débats parlementaires.
 * @export
 * @interface DebatsParlementairesListResponse
 */
export interface DebatsParlementairesListResponse {
    /**
     * 
     * @type {Facet}
     * @memberof DebatsParlementairesListResponse
     */
    'typesPublication'?: Facet;
    /**
     * Liste des résultats de la page
     * @type {Array<Debat>}
     * @memberof DebatsParlementairesListResponse
     */
    'results'?: Array<Debat>;
    /**
     * Taille du fichier avec son unité
     * @type {string}
     * @memberof DebatsParlementairesListResponse
     */
    'displaySize'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof DebatsParlementairesListResponse
     */
    'executionTime'?: number;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof DebatsParlementairesListResponse
     */
    'totalResultNumber'?: number;
    /**
     * 
     * @type {Facet}
     * @memberof DebatsParlementairesListResponse
     */
    'typePublicationFacet'?: Facet;
}
/**
 * Objet représentant une décision attaquée
 * @export
 * @interface DecisionAttaquee
 */
export interface DecisionAttaquee {
    /**
     * formation
     * @type {string}
     * @memberof DecisionAttaquee
     */
    'formation'?: string;
    /**
     * Date de la décision
     * @type {string}
     * @memberof DecisionAttaquee
     */
    'date'?: string;
}
/**
 * Objet représentant le détail d\'un élément du contexte
 * @export
 * @interface DetailContext
 */
export interface DetailContext {
    /**
     * Identifiant technique
     * @type {string}
     * @memberof DetailContext
     */
    'id'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof DetailContext
     */
    'titre'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof DetailContext
     */
    'debut'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof DetailContext
     */
    'fin'?: string;
    /**
     * Chronical ID
     * @type {string}
     * @memberof DetailContext
     */
    'cid'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof DetailContext
     */
    'etat'?: string;
    /**
     * Chemin pour arriver à l\'élément dans le XML
     * @type {string}
     * @memberof DetailContext
     */
    'xPath'?: string;
}
/**
 * Requête pour lister les documents administratifs
 * @export
 * @interface DocsAdminsListRequest
 */
export interface DocsAdminsListRequest {
    /**
     * Liste des années à filtrer
     * @type {Array<string>}
     * @memberof DocsAdminsListRequest
     */
    'years'?: Array<string>;
}
/**
 * Résultat d\'une requête pour lister les documents administratifs
 * @export
 * @interface DocsAdminsListResponse
 */
export interface DocsAdminsListResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof DocsAdminsListResponse
     */
    'executionTime'?: number;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof DocsAdminsListResponse
     */
    'totalResultNumber'?: number;
    /**
     * Liste des résultats de la page
     * @type {Array<DocumentAdministratif>}
     * @memberof DocsAdminsListResponse
     */
    'results'?: Array<DocumentAdministratif>;
    /**
     * 
     * @type {Facet}
     * @memberof DocsAdminsListResponse
     */
    'years'?: Facet;
}
/**
 * Objet représentant un document administratif
 * @export
 * @interface DocumentAdministratif
 */
export interface DocumentAdministratif {
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'refInjection'?: string;
    /**
     * Sous-titre
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'sousTitre'?: string;
    /**
     * Date du JO
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'dateJO'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'titre'?: string;
    /**
     * Chemin vers le fichier attaché
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'attachmentUrl'?: string;
    /**
     * Date du document
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'dateDocument'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'origine'?: string;
    /**
     * Chemin vers le fichier xml
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'url'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'nature'?: string;
    /**
     * Taille du fichier avec son unité
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'displaySize'?: string;
    /**
     * Numéro
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'numero'?: string;
    /**
     * Nom du fichier
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'attachmentName'?: string;
    /**
     * Identifiant unique
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'id'?: string;
    /**
     * Ancien ID
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'ancienId'?: string;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'idTechInjection'?: string;
    /**
     * Numéro NOR
     * @type {string}
     * @memberof DocumentAdministratif
     */
    'nor'?: string;
}
/**
 * Objet représentant un dossier pour les dossiers legislatifs
 * @export
 * @interface Dossier
 */
export interface Dossier {
    /**
     * Identifiant
     * @type {string}
     * @memberof Dossier
     */
    'idTexte'?: string;
    /**
     * Libellé
     * @type {string}
     * @memberof Dossier
     */
    'libelleTexte'?: string;
    /**
     * Contenu html du dossier
     * @type {string}
     * @memberof Dossier
     */
    'contenuDossier'?: string;
}
/**
 * Objet représentant un dossier législatif
 * @export
 * @interface DossierLegislatif
 */
export interface DossierLegislatif {
    /**
     * Texte html des motifs
     * @type {string}
     * @memberof DossierLegislatif
     */
    'exposeMotif'?: string;
    /**
     * type
     * @type {string}
     * @memberof DossierLegislatif
     */
    'type'?: string;
    /**
     * 
     * @type {Legislature}
     * @memberof DossierLegislatif
     */
    'legislature'?: Legislature;
    /**
     * Date de dernière modification de l\'échéancier
     * @type {string}
     * @memberof DossierLegislatif
     */
    'dateMajEcheancier'?: string;
    /**
     * Identifiant du dossier
     * @type {string}
     * @memberof DossierLegislatif
     */
    'id'?: string;
    /**
     * Echéancier
     * @type {string}
     * @memberof DossierLegislatif
     */
    'echeancier'?: string;
    /**
     * Date de dernière modification
     * @type {string}
     * @memberof DossierLegislatif
     */
    'dateDerniereModification'?: string;
    /**
     * chemin relatif vers le fichier xml
     * @type {string}
     * @memberof DossierLegislatif
     */
    'url'?: string;
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof DossierLegislatif
     */
    'refInjection'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof DossierLegislatif
     */
    'origine'?: string;
    /**
     * 
     * @type {Arborescence}
     * @memberof DossierLegislatif
     */
    'arborescence'?: Arborescence;
    /**
     * Titre du dossier legislatif
     * @type {string}
     * @memberof DossierLegislatif
     */
    'titre'?: string;
    /**
     * nature
     * @type {string}
     * @memberof DossierLegislatif
     */
    'nature'?: string;
    /**
     * Date de création
     * @type {string}
     * @memberof DossierLegislatif
     */
    'dateCreation'?: string;
    /**
     * Liste des dossiers
     * @type {Array<Dossier>}
     * @memberof DossierLegislatif
     */
    'dossiers'?: Array<Dossier>;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof DossierLegislatif
     */
    'idTechInjection'?: string;
    /**
     * Ancien ID
     * @type {string}
     * @memberof DossierLegislatif
     */
    'ancienId'?: string;
}
/**
 * Requête de consultation d\'un dossier législatif
 * @export
 * @interface DossierLegislatifRequest
 */
export interface DossierLegislatifRequest {
    /**
     * Identifiant du dossier législatif
     * @type {string}
     * @memberof DossierLegislatifRequest
     */
    'id': string;
}
/**
 * Objet représentant le résultat d\'un dossier législatif
 * @export
 * @interface DossierLegislatifResult
 */
export interface DossierLegislatifResult {
    /**
     * Titre
     * @type {string}
     * @memberof DossierLegislatifResult
     */
    'titre'?: string;
    /**
     * Type
     * @type {string}
     * @memberof DossierLegislatifResult
     */
    'type'?: string;
    /**
     * Identifiant
     * @type {string}
     * @memberof DossierLegislatifResult
     */
    'id'?: string;
    /**
     * Date de création
     * @type {string}
     * @memberof DossierLegislatifResult
     */
    'dateCreation'?: string;
    /**
     * Liste des dossiers
     * @type {Array<DossierResult>}
     * @memberof DossierLegislatifResult
     */
    'dossiers'?: Array<DossierResult>;
    /**
     * Date de dernière modification
     * @type {string}
     * @memberof DossierLegislatifResult
     */
    'dateDerniereModification'?: string;
}
/**
 * Objet représentant un dossier
 * @export
 * @interface DossierResult
 */
export interface DossierResult {
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof DossierResult
     */
    'idTexte'?: string;
    /**
     * Titre du texte
     * @type {string}
     * @memberof DossierResult
     */
    'libelleTexte'?: string;
}
/**
 * Résultat d\'une requête pour lister les dossiers législatifs d\'une législature
 * @export
 * @interface DossiersLegislatifsListResponse
 */
export interface DossiersLegislatifsListResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof DossiersLegislatifsListResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {Legislature}
     * @memberof DossiersLegislatifsListResponse
     */
    'legislature'?: Legislature;
    /**
     * Liste des dossiers législatifs répondant à la requête
     * @type {Array<DossierLegislatifResult>}
     * @memberof DossiersLegislatifsListResponse
     */
    'dossiersLegislatifs'?: Array<DossierLegislatifResult>;
}
/**
 * Requête pour lister les dossiers législatifs d\'une législature
 * @export
 * @interface DossiersLegislatifsRequest
 */
export interface DossiersLegislatifsRequest {
    /**
     * Identifiant de la législature
     * @type {number}
     * @memberof DossiersLegislatifsRequest
     */
    'legislatureId': number;
    /**
     * Type de dossier législatif
     * @type {string}
     * @memberof DossiersLegislatifsRequest
     */
    'type': DossiersLegislatifsRequestTypeEnum;
}

export const DossiersLegislatifsRequestTypeEnum = {
    LoiPubliee: 'LOI_PUBLIEE',
    OrdonnancePubliee: 'ORDONNANCE_PUBLIEE',
    ProjetLoi: 'PROJET_LOI',
    PropositionLoi: 'PROPOSITION_LOI'
} as const;

export type DossiersLegislatifsRequestTypeEnum = typeof DossiersLegislatifsRequestTypeEnum[keyof typeof DossiersLegislatifsRequestTypeEnum];

/**
 * Objet représentant les informations d\'un index
 * @export
 * @interface ElasticData
 */
export interface ElasticData {
    /**
     * Date du dernier document indexé
     * @type {string}
     * @memberof ElasticData
     */
    'lastIndex'?: string;
    /**
     * Nombre de documents
     * @type {number}
     * @memberof ElasticData
     */
    'nbDoc'?: number;
    /**
     * Description de l\'usage de l\'index
     * @type {string}
     * @memberof ElasticData
     */
    'usage'?: string;
    /**
     * Nom de l\'index
     * @type {string}
     * @memberof ElasticData
     */
    'indexName'?: string;
}
/**
 * Résultat d\'une requête pour récupérer les informations sur les index ElasticSearch
 * @export
 * @interface ElasticDataResponse
 */
export interface ElasticDataResponse {
    /**
     * Liste des informations par index
     * @type {Array<ElasticData>}
     * @memberof ElasticDataResponse
     */
    'lstData'?: Array<ElasticData>;
}
/**
 * 
 * @export
 * @interface EsGlobalBocc
 */
export interface EsGlobalBocc {
    /**
     * 
     * @type {string}
     * @memberof EsGlobalBocc
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsGlobalBocc
     */
    'pathFile'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsGlobalBocc
     */
    'dateParution'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsGlobalBocc
     */
    'numParution'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsGlobalBocc
     */
    'displaySize'?: string;
}
/**
 * 
 * @export
 * @interface EsParutionBocc
 */
export interface EsParutionBocc {
    /**
     * 
     * @type {string}
     * @memberof EsParutionBocc
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsParutionBocc
     */
    'refInjection'?: string;
    /**
     * 
     * @type {EsGlobalBocc}
     * @memberof EsParutionBocc
     */
    'globalBocc'?: EsGlobalBocc;
    /**
     * 
     * @type {Array<EsTextBocc>}
     * @memberof EsParutionBocc
     */
    'texts'?: Array<EsTextBocc>;
    /**
     * 
     * @type {string}
     * @memberof EsParutionBocc
     */
    'idTechInjection'?: string;
}
/**
 * 
 * @export
 * @interface EsQuestionsEcritesParlementaires
 */
export interface EsQuestionsEcritesParlementaires {
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'refInjection'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'origine'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'pathToFile'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'emetteur'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'pdfName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'displaySize'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'numeroParution'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'dateParution'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsQuestionsEcritesParlementaires
     */
    'idTechInjection'?: string;
}
/**
 * 
 * @export
 * @interface EsTextBocc
 */
export interface EsTextBocc {
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'idMainBocc'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'enteteTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'pathFile'?: string;
    /**
     * 
     * @type {number}
     * @memberof EsTextBocc
     */
    'numAnn'?: number;
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'displaySize'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'department'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EsTextBocc
     */
    'texteDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EsTextBocc
     */
    'idccs'?: Array<string>;
}
/**
 * Objet représentant une facette
 * @export
 * @interface Facet
 */
export interface Facet {
    /**
     * Liste au format map des libellés d\'une facette ainsi que le nombre de résultats associés
     * @type {{ [key: string]: number; }}
     * @memberof Facet
     */
    'values'?: { [key: string]: number; };
    /**
     * Nom de la facette
     * @type {string}
     * @memberof Facet
     */
    'facetElem'?: string;
    /**
     * Liste au format map des éléments enfants d\'un élément particulier d\'une facette ainsi que le nombre de résultats associés. La clé permet de déterminer le parent de cette liste dans les libellés values.
     * @type {{ [key: string]: Facet; }}
     * @memberof Facet
     */
    'childs'?: { [key: string]: Facet; };
    /**
     * 1560
     * @type {number}
     * @memberof Facet
     */
    'totalElement'?: number;
    /**
     * Nom du champ représentant la facette
     * @type {string}
     * @memberof Facet
     */
    'field'?: string;
}
/**
 * Objet représentant les métadonnées d\'un fichier
 * @export
 * @interface FileMetadata
 */
export interface FileMetadata {
    /**
     * Type de fichier
     * @type {string}
     * @memberof FileMetadata
     */
    'type'?: string;
    /**
     * Nom du fichier
     * @type {string}
     * @memberof FileMetadata
     */
    'fileName'?: string;
    /**
     * Numéro complémentaire pour le fonds JORF
     * @type {string}
     * @memberof FileMetadata
     */
    'complementNumber'?: string;
    /**
     * Numéro du JO pour le fonds JORF
     * @type {string}
     * @memberof FileMetadata
     */
    'num'?: string;
    /**
     * Taille du fichier avec son unité
     * @type {string}
     * @memberof FileMetadata
     */
    'displaySize'?: string;
    /**
     * Identifiant du fichier dans la base de données
     * @type {string}
     * @memberof FileMetadata
     */
    'id'?: string;
    /**
     * Chemin relatif vers le fichier
     * @type {string}
     * @memberof FileMetadata
     */
    'pathToFile'?: string;
    /**
     * Date de publication
     * @type {string}
     * @memberof FileMetadata
     */
    'datePubli'?: string;
    /**
     * Origine du fichier
     * @type {string}
     * @memberof FileMetadata
     */
    'origine'?: string;
    /**
     * Taille du fichier en octets
     * @type {number}
     * @memberof FileMetadata
     */
    'size'?: number;
}
/**
 * Objet décrivant un filtre de recherche
 * @export
 * @interface FiltreDTO
 */
export interface FiltreDTO {
    /**
     * Liste des valeurs du filtre dans le cas d\'un filtre textuel ou d\'un filtre via option textuelle
     * @type {Array<string>}
     * @memberof FiltreDTO
     */
    'valeurs'?: Array<string>;
    /**
     * Map des sous-valeur d\'une valeur de filtre dans le cas d\'un filtre par option texte. La clé doit être la valeur correspondante au parent dans la liste \'valeurs\'
     * @type {{ [key: string]: Array<string>; }}
     * @memberof FiltreDTO
     */
    'multiValeurs'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {DatePeriod}
     * @memberof FiltreDTO
     */
    'dates'?: DatePeriod;
    /**
     * Nom de la facette => nom du filtre
     * @type {string}
     * @memberof FiltreDTO
     */
    'facette'?: string;
    /**
     * Date unique dans le cas d\'un filtre par date
     * @type {string}
     * @memberof FiltreDTO
     */
    'singleDate'?: string;
}
/**
 * Objet représentant un conteneur
 * @export
 * @interface FullConteneur
 */
export interface FullConteneur {
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof FullConteneur
     */
    'refInjection'?: string;
    /**
     * Numéro de JO
     * @type {string}
     * @memberof FullConteneur
     */
    'num'?: string;
    /**
     * 
     * @type {StructureTxt}
     * @memberof FullConteneur
     */
    'structure'?: StructureTxt;
    /**
     * chemin vers le conteneur
     * @type {string}
     * @memberof FullConteneur
     */
    'url'?: string;
    /**
     * Identifiant ELI
     * @type {string}
     * @memberof FullConteneur
     */
    'idEli'?: string;
    /**
     * Identifiant du conteneur
     * @type {string}
     * @memberof FullConteneur
     */
    'id'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof FullConteneur
     */
    'origine'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof FullConteneur
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullConteneur
     */
    'relevantDate'?: string;
    /**
     * Nature du conteneur
     * @type {string}
     * @memberof FullConteneur
     */
    'nature'?: string;
    /**
     * Date de publication
     * @type {string}
     * @memberof FullConteneur
     */
    'datePubli'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullConteneur
     */
    'numero'?: string;
    /**
     * Etat juridique du conteneur
     * @type {string}
     * @memberof FullConteneur
     */
    'etat'?: string;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof FullConteneur
     */
    'idTechInjection'?: string;
    /**
     * Ancien Identifiant
     * @type {string}
     * @memberof FullConteneur
     */
    'ancienId'?: string;
}
/**
 * réponse de consultation d\'un article
 * @export
 * @interface GetArticleResponse
 */
export interface GetArticleResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof GetArticleResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {Article}
     * @memberof GetArticleResponse
     */
    'article'?: Article;
    /**
     * Identifie si le contenu est référençable par les robots d\'indexation
     * @type {boolean}
     * @memberof GetArticleResponse
     */
    'dereferenced'?: boolean;
}
/**
 * Réponse à une requête de N derniers JO
 * @export
 * @interface GetJorfContResponse
 */
export interface GetJorfContResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof GetJorfContResponse
     */
    'executionTime'?: number;
    /**
     * Liste des N derniers conteneurs
     * @type {Array<Conteneur>}
     * @memberof GetJorfContResponse
     */
    'containers'?: Array<Conteneur>;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof GetJorfContResponse
     */
    'totalNbResult'?: number;
}
/**
 * Élément de réponse à une recheche de JO
 * @export
 * @interface GetJorfContResponseItem
 */
export interface GetJorfContResponseItem {
    /**
     * 
     * @type {FileMetadata}
     * @memberof GetJorfContResponseItem
     */
    'joEA'?: FileMetadata;
    /**
     * 
     * @type {FileMetadata}
     * @memberof GetJorfContResponseItem
     */
    'joInap'?: FileMetadata;
    /**
     * 
     * @type {FullConteneur}
     * @memberof GetJorfContResponseItem
     */
    'joCont'?: FullConteneur;
    /**
     * Liste des métadonnées des JO patrimoniaux
     * @type {Array<FileMetadata>}
     * @memberof GetJorfContResponseItem
     */
    'josPat'?: Array<FileMetadata>;
}
/**
 * Réponse à une requête de recherche de JO
 * @export
 * @interface GetJosResponse
 */
export interface GetJosResponse {
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof GetJosResponse
     */
    'totalNbResult'?: number;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof GetJosResponse
     */
    'executionTime'?: number;
    /**
     * Liste des éléments trouvés
     * @type {Array<GetJorfContResponseItem>}
     * @memberof GetJosResponse
     */
    'items'?: Array<GetJorfContResponseItem>;
}
/**
 * réponse de consultation d\'un article par son Chronical ID
 * @export
 * @interface GetListArticleResponse
 */
export interface GetListArticleResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof GetListArticleResponse
     */
    'executionTime'?: number;
    /**
     * Liste des versions de l\'article
     * @type {Array<Article>}
     * @memberof GetListArticleResponse
     */
    'listArticle'?: Array<Article>;
}
/**
 * réponse de consultation des plans de classement Juri
 * @export
 * @interface GetListPlanClassementJuriResponse
 */
export interface GetListPlanClassementJuriResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof GetListPlanClassementJuriResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {Array<Nomenclature>}
     * @memberof GetListPlanClassementJuriResponse
     */
    'listPlanClassementJuri'?: Array<Nomenclature>;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof GetListPlanClassementJuriResponse
     */
    'totalNbResult'?: number;
}
/**
 * réponse de consultation d\'une liste de sections par son Chronical CID
 * @export
 * @interface GetListSectionResponse
 */
export interface GetListSectionResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof GetListSectionResponse
     */
    'executionTime'?: number;
    /**
     * Liste des sections
     * @type {Array<Section>}
     * @memberof GetListSectionResponse
     */
    'listSection'?: Array<Section>;
}
/**
 * réponse de récupération des tables annuelles
 * @export
 * @interface GetTableResponse
 */
export interface GetTableResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof GetTableResponse
     */
    'executionTime'?: number;
    /**
     * Liste des tables trouvées
     * @type {Array<FileMetadata>}
     * @memberof GetTableResponse
     */
    'tables'?: Array<FileMetadata>;
    /**
     * 
     * @type {number}
     * @memberof GetTableResponse
     */
    'totalNbResult'?: number;
}
/**
 * 
 * @export
 * @interface GlobalBoccListRequest
 */
export interface GlobalBoccListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof GlobalBoccListRequest
     */
    'pageSize': number;
    /**
     * 
     * @type {boolean}
     * @memberof GlobalBoccListRequest
     */
    'searchForSingleGlobalBocc'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GlobalBoccListRequest
     */
    'intervalPublication'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalBoccListRequest
     */
    'idGlobalBocc'?: string;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof GlobalBoccListRequest
     */
    'pageNumber': number;
    /**
     * 
     * @type {string}
     * @memberof GlobalBoccListRequest
     */
    'sortValue'?: string;
}
/**
 * Réponse indiquant s\'il existe un chronolegi (plusieurs versions) pour le texte.
 * @export
 * @interface HasChronolegiResponse
 */
export interface HasChronolegiResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof HasChronolegiResponse
     */
    'executionTime'?: number;
    /**
     * Indique si un versionning existe
     * @type {boolean}
     * @memberof HasChronolegiResponse
     */
    'chronolegiExists'?: boolean;
}
/**
 * requête de consultation d\'un texte JORF
 * @export
 * @interface JorfConsultRequest
 */
export interface JorfConsultRequest {
    /**
     * Chronical ID de l\'élément
     * @type {string}
     * @memberof JorfConsultRequest
     */
    'textCid': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof JorfConsultRequest
     */
    'searchedString'?: string;
}
/**
 * Requête de consultation d\'un JORF à partir de son URL de type ELI ou Alias.
 * @export
 * @interface JorfConsultWithIdEliAliasRequest
 */
export interface JorfConsultWithIdEliAliasRequest {
    /**
     * ID Eli ou Alias du JORF cible.
     * @type {string}
     * @memberof JorfConsultWithIdEliAliasRequest
     */
    'idEliOrAlias': string;
}
/**
 * Requête de consultation d\'un JORF à partir de son NOR.
 * @export
 * @interface JorfConsultWithNorRequest
 */
export interface JorfConsultWithNorRequest {
    /**
     * NOR
     * @type {string}
     * @memberof JorfConsultWithNorRequest
     */
    'nor': string;
}
/**
 * requête de consultation d\'un conteneur JORF
 * @export
 * @interface JorfContConsultRequest
 */
export interface JorfContConsultRequest {
    /**
     * Activer/Désactiver le highlight, dans la réponse, du texte recherché
     * @type {boolean}
     * @memberof JorfContConsultRequest
     */
    'highlightActivated'?: boolean;
    /**
     * 
     * @type {ConsultDateRequest}
     * @memberof JorfContConsultRequest
     */
    'end'?: ConsultDateRequest;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof JorfContConsultRequest
     */
    'pageNumber'?: number;
    /**
     * Date de référence
     * @type {string}
     * @memberof JorfContConsultRequest
     */
    'date'?: string;
    /**
     * identifiant du conteneur JORF recherché
     * @type {string}
     * @memberof JorfContConsultRequest
     */
    'id'?: string;
    /**
     * numéro de JORF recherché
     * @type {string}
     * @memberof JorfContConsultRequest
     */
    'num'?: string;
    /**
     * Texte à rechercher
     * @type {string}
     * @memberof JorfContConsultRequest
     */
    'searchText'?: string;
    /**
     * Nombre d\'éléments par page (max 100)
     * @type {number}
     * @memberof JorfContConsultRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {ConsultDateRequest}
     * @memberof JorfContConsultRequest
     */
    'start'?: ConsultDateRequest;
}
/**
 * requête de consultation d\'un texte de Jurisprudence judiciaire
 * @export
 * @interface JuriConsultRequest
 */
export interface JuriConsultRequest {
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof JuriConsultRequest
     */
    'textId': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof JuriConsultRequest
     */
    'searchedString'?: string;
}
/**
 * requête de consultation d\'un texte du fonds JURI avec ancien ID
 * @export
 * @interface JuriConsultWithAncienId
 */
export interface JuriConsultWithAncienId {
    /**
     * Ancien Id afin de consulter un texte des fonds JURI
     * @type {string}
     * @memberof JuriConsultWithAncienId
     */
    'ancienId'?: string;
}
/**
 * requête de consultation d\'un jurinome du fonds JURI
 * @export
 * @interface JuriPlanClassementRequest
 */
export interface JuriPlanClassementRequest {
    /**
     * le fond a rechercher
     * @type {string}
     * @memberof JuriPlanClassementRequest
     */
    'fond'?: string;
    /**
     * niveau ou nous nous trouvons
     * @type {number}
     * @memberof JuriPlanClassementRequest
     */
    'niveau'?: number;
    /**
     * recherche par suggestion
     * @type {boolean}
     * @memberof JuriPlanClassementRequest
     */
    'searchSuggest'?: boolean;
    /**
     * recherche par niveau
     * @type {boolean}
     * @memberof JuriPlanClassementRequest
     */
    'searchByNiveau'?: boolean;
    /**
     * id du JURINOME
     * @type {string}
     * @memberof JuriPlanClassementRequest
     */
    'id'?: string;
    /**
     * id du JURINOME
     * @type {string}
     * @memberof JuriPlanClassementRequest
     */
    'libelle'?: string;
    /**
     * la requete ELK
     * @type {number}
     * @memberof JuriPlanClassementRequest
     */
    'page'?: number;
}
/**
 * Requête de consultation d\'une convention collective
 * @export
 * @interface KaliContConsultIdccRequest
 */
export interface KaliContConsultIdccRequest {
    /**
     * Identifiant de la convention collective ou son numéro IDCC
     * @type {string}
     * @memberof KaliContConsultIdccRequest
     */
    'id': string;
}
/**
 * Requête de consultation d\'une convention collective
 * @export
 * @interface KaliContConsultRequest
 */
export interface KaliContConsultRequest {
    /**
     * Identifiant de la convention collective ou son numéro IDCC
     * @type {string}
     * @memberof KaliContConsultRequest
     */
    'id': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof KaliContConsultRequest
     */
    'searchedString'?: string;
}
/**
 * Requête de consultation d\'un texte d\'une convention collective
 * @export
 * @interface KaliTextConsultArticleRequest
 */
export interface KaliTextConsultArticleRequest {
    /**
     * Identifiant du texte ou d\'un de ses éléments enfants (section/article)
     * @type {string}
     * @memberof KaliTextConsultArticleRequest
     */
    'id': string;
}
/**
 * Requête de consultation d\'un texte d\'une convention collective
 * @export
 * @interface KaliTextConsultRequest
 */
export interface KaliTextConsultRequest {
    /**
     * Identifiant du texte ou d\'un de ses éléments enfants (section/article)
     * @type {string}
     * @memberof KaliTextConsultRequest
     */
    'id': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof KaliTextConsultRequest
     */
    'searchedString'?: string;
}
/**
 * Requête de consultation d\'un texte d\'une convention collective
 * @export
 * @interface KaliTextConsultSectionRequest
 */
export interface KaliTextConsultSectionRequest {
    /**
     * Identifiant du texte ou d\'un de ses éléments enfants (section/article)
     * @type {string}
     * @memberof KaliTextConsultSectionRequest
     */
    'id': string;
}
/**
 * Requête paginée pour lister les textes Lois, Décrets, Arrêtés
 * @export
 * @interface LODAListRequest
 */
export interface LODAListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof LODAListRequest
     */
    'pageSize': number;
    /**
     * Liste des états juridiques à filtrer
     * @type {Array<string>}
     * @memberof LODAListRequest
     */
    'legalStatus'?: Array<LODAListRequestLegalStatusEnum>;
    /**
     * Ordre de tri
     * @type {string}
     * @memberof LODAListRequest
     */
    'sort'?: LODAListRequestSortEnum;
    /**
     * 
     * @type {DatePeriod}
     * @memberof LODAListRequest
     */
    'signatureDate'?: DatePeriod;
    /**
     * Ordre de tri
     * @type {string}
     * @memberof LODAListRequest
     */
    'secondSort'?: LODAListRequestSecondSortEnum;
    /**
     * Liste des natures à filtrer
     * @type {Array<string>}
     * @memberof LODAListRequest
     */
    'natures'?: Array<LODAListRequestNaturesEnum>;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof LODAListRequest
     */
    'pageNumber': number;
    /**
     * 
     * @type {DatePeriod}
     * @memberof LODAListRequest
     */
    'publicationDate'?: DatePeriod;
}

export const LODAListRequestLegalStatusEnum = {
    Vigueur: 'VIGUEUR',
    AbrogeDiff: 'ABROGE_DIFF',
    VigueurDiff: 'VIGUEUR_DIFF',
    VigueurEten: 'VIGUEUR_ETEN',
    VigueurNonEten: 'VIGUEUR_NON_ETEN',
    Abroge: 'ABROGE',
    Perime: 'PERIME',
    Annule: 'ANNULE',
    Modifie: 'MODIFIE',
    Disjoint: 'DISJOINT',
    Substitue: 'SUBSTITUE',
    Transfere: 'TRANSFERE',
    Initiale: 'INITIALE',
    ModifieMortNe: 'MODIFIE_MORT_NE',
    SansEtat: 'SANS_ETAT',
    Denonce: 'DENONCE',
    Remplace: 'REMPLACE'
} as const;

export type LODAListRequestLegalStatusEnum = typeof LODAListRequestLegalStatusEnum[keyof typeof LODAListRequestLegalStatusEnum];
export const LODAListRequestSortEnum = {
    PublicationDateAsc: 'PUBLICATION_DATE_ASC',
    PublicationDateDesc: 'PUBLICATION_DATE_DESC',
    SignatureDateDesc: 'SIGNATURE_DATE_DESC',
    SignatureDateAsc: 'SIGNATURE_DATE_ASC',
    IdAsc: 'ID_ASC',
    IdDesc: 'ID_DESC'
} as const;

export type LODAListRequestSortEnum = typeof LODAListRequestSortEnum[keyof typeof LODAListRequestSortEnum];
export const LODAListRequestSecondSortEnum = {
    PublicationDateAsc: 'PUBLICATION_DATE_ASC',
    PublicationDateDesc: 'PUBLICATION_DATE_DESC',
    SignatureDateDesc: 'SIGNATURE_DATE_DESC',
    SignatureDateAsc: 'SIGNATURE_DATE_ASC',
    IdAsc: 'ID_ASC',
    IdDesc: 'ID_DESC'
} as const;

export type LODAListRequestSecondSortEnum = typeof LODAListRequestSecondSortEnum[keyof typeof LODAListRequestSecondSortEnum];
export const LODAListRequestNaturesEnum = {
    Loi: 'LOI',
    Ordonnance: 'ORDONNANCE',
    Decret: 'DECRET',
    DecretLoi: 'DECRET_LOI',
    Arrete: 'ARRETE',
    Constitution: 'CONSTITUTION',
    Decision: 'DECISION',
    Convention: 'CONVENTION',
    Declaration: 'DECLARATION',
    AccordFonctionPublique: 'ACCORD_FONCTION_PUBLIQUE'
} as const;

export type LODAListRequestNaturesEnum = typeof LODAListRequestNaturesEnum[keyof typeof LODAListRequestNaturesEnum];

/**
 * Résultat d\'une requête paginée pour lister les textes Lois, Décrets, Arrêtés
 * @export
 * @interface LODAListResponse
 */
export interface LODAListResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof LODAListResponse
     */
    'executionTime'?: number;
    /**
     * Liste des résultats de la page
     * @type {Array<LODAListResult>}
     * @memberof LODAListResponse
     */
    'results'?: Array<LODAListResult>;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof LODAListResponse
     */
    'totalResultNumber'?: number;
    /**
     * 
     * @type {Facet}
     * @memberof LODAListResponse
     */
    'natures'?: Facet;
    /**
     * 
     * @type {Facet}
     * @memberof LODAListResponse
     */
    'legalStatus'?: Facet;
}
/**
 * Objet représentant un résultat LODA
 * @export
 * @interface LODAListResult
 */
export interface LODAListResult {
    /**
     * Identifiant unique
     * @type {string}
     * @memberof LODAListResult
     */
    'id'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof LODAListResult
     */
    'titre'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof LODAListResult
     */
    'dateDebut'?: string;
    /**
     * Date de dernière mise à jour
     * @type {string}
     * @memberof LODAListResult
     */
    'lastUpdate'?: string;
    /**
     * Chronical ID
     * @type {string}
     * @memberof LODAListResult
     */
    'cid'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof LODAListResult
     */
    'etat'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof LODAListResult
     */
    'dateFin'?: string;
    /**
     * Liste des dossiers législatifs
     * @type {Array<DossierLegislatif>}
     * @memberof LODAListResult
     */
    'dossiersLegislatifs'?: Array<DossierLegislatif>;
}
/**
 * requête de récupération des derniers JO
 * @export
 * @interface LastNElementRequest
 */
export interface LastNElementRequest {
    /**
     * Nombre de JO à remonter
     * @type {number}
     * @memberof LastNElementRequest
     */
    'nbElement': number;
}
/**
 * Requête de consultation d\'un texte du fonds Legi.
 * @export
 * @interface LawDecreeConsultRequest
 */
export interface LawDecreeConsultRequest {
    /**
     * 
     * @type {boolean}
     * @memberof LawDecreeConsultRequest
     */
    'fromSuggest'?: boolean;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof LawDecreeConsultRequest
     */
    'textId': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof LawDecreeConsultRequest
     */
    'searchedString'?: string;
    /**
     * Date de consultation
     * @type {string}
     * @memberof LawDecreeConsultRequest
     */
    'date': string;
}
/**
 * Requête de consultation d\'un texte du fonds Legi.
 * @export
 * @interface LegiConsultRequest
 */
export interface LegiConsultRequest {
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof LegiConsultRequest
     */
    'textId': string;
    /**
     * Texte de la recherche ayant aboutie à la consultation du texte
     * @type {string}
     * @memberof LegiConsultRequest
     */
    'searchedString'?: string;
    /**
     * Date de consultation
     * @type {string}
     * @memberof LegiConsultRequest
     */
    'date': string;
}
/**
 * Requête de consultation du sommaire d\'un texte du fond Legi.
 * @export
 * @interface LegiSommaireConsultRequest
 */
export interface LegiSommaireConsultRequest {
    /**
     * id OU cid du texte
     * @type {string}
     * @memberof LegiSommaireConsultRequest
     */
    'textId': string;
    /**
     * Nature du texte recherché : CODE, DECRET, ARRETE, LOI, ORDONNANCE...
     * @type {string}
     * @memberof LegiSommaireConsultRequest
     */
    'nature'?: string;
    /**
     * Date de consultation
     * @type {string}
     * @memberof LegiSommaireConsultRequest
     */
    'date': string;
}
/**
 * Objet représentant une législature
 * @export
 * @interface Legislature
 */
export interface Legislature {
    /**
     * Identifiant
     * @type {string}
     * @memberof Legislature
     */
    'id'?: string;
    /**
     * libellé
     * @type {string}
     * @memberof Legislature
     */
    'libelle'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof Legislature
     */
    'dateDebut'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof Legislature
     */
    'dateFin'?: string;
}
/**
 * Résultat d\'une requête pour lister les législatures
 * @export
 * @interface LegislaturesListResponse
 */
export interface LegislaturesListResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof LegislaturesListResponse
     */
    'executionTime'?: number;
    /**
     * Liste des législatures
     * @type {Array<Legislature>}
     * @memberof LegislaturesListResponse
     */
    'legislatures'?: Array<Legislature>;
}
/**
 * Objet représentant un lien dans l\'arborescence d\'un dossier législatif
 * @export
 * @interface Lien
 */
export interface Lien {
    /**
     * Identifiant du lien
     * @type {string}
     * @memberof Lien
     */
    'id'?: string;
    /**
     * Libellé
     * @type {string}
     * @memberof Lien
     */
    'libelle'?: string;
    /**
     * Texte associé
     * @type {string}
     * @memberof Lien
     */
    'data'?: string;
    /**
     * Lien vers le dossier législatif
     * @type {string}
     * @memberof Lien
     */
    'lien'?: string;
}
/**
 * Objet représentant un lien de citation
 * @export
 * @interface LienCitation
 */
export interface LienCitation {
    /**
     * 
     * @type {string}
     * @memberof LienCitation
     */
    'parentCid'?: string;
    /**
     * Type de lien
     * @type {string}
     * @memberof LienCitation
     */
    'linkType'?: string;
    /**
     * 
     * @type {string}
     * @memberof LienCitation
     */
    'numTexte'?: string;
    /**
     * 
     * @type {string}
     * @memberof LienCitation
     */
    'date'?: string;
    /**
     * Chronical ID du texte lié
     * @type {string}
     * @memberof LienCitation
     */
    'textCid'?: string;
    /**
     * Nature du texte lié
     * @type {string}
     * @memberof LienCitation
     */
    'natureText'?: string;
    /**
     * 
     * @type {string}
     * @memberof LienCitation
     */
    'dateDebut'?: string;
    /**
     * Identifiant de l\'article lié
     * @type {string}
     * @memberof LienCitation
     */
    'articleId'?: string;
    /**
     * Numéro de l\'article lié
     * @type {string}
     * @memberof LienCitation
     */
    'articleNum'?: string;
    /**
     * Sens de la modification
     * @type {string}
     * @memberof LienCitation
     */
    'linkOrientation'?: string;
    /**
     * 
     * @type {string}
     * @memberof LienCitation
     */
    'datePubli'?: string;
    /**
     * Titre du texte lié
     * @type {string}
     * @memberof LienCitation
     */
    'textTitle'?: string;
}
/**
 * 
 * @export
 * @interface LienConcorde
 */
export interface LienConcorde {
    /**
     * Nature du texte lié
     * @type {string}
     * @memberof LienConcorde
     */
    'natureText'?: string;
    /**
     * Identifiant de l\'article lié
     * @type {string}
     * @memberof LienConcorde
     */
    'articleId'?: string;
    /**
     * Titre du texte lié
     * @type {string}
     * @memberof LienConcorde
     */
    'textTitle'?: string;
    /**
     * Numéro de l\'article lié
     * @type {string}
     * @memberof LienConcorde
     */
    'articleNum'?: string;
    /**
     * Sens de la modification
     * @type {string}
     * @memberof LienConcorde
     */
    'linkOrientation'?: string;
    /**
     * Type de lien
     * @type {string}
     * @memberof LienConcorde
     */
    'linkType'?: string;
    /**
     * Chronical ID du texte lié
     * @type {string}
     * @memberof LienConcorde
     */
    'textCid'?: string;
}
/**
 * Objet représentant un lien de modification
 * @export
 * @interface LienModification
 */
export interface LienModification {
    /**
     * Type de lien
     * @type {string}
     * @memberof LienModification
     */
    'linkType'?: string;
    /**
     * Date de signature du texte lié
     * @type {string}
     * @memberof LienModification
     */
    'dateSignaTexte'?: string;
    /**
     * Nature du texte lié
     * @type {string}
     * @memberof LienModification
     */
    'natureText'?: string;
    /**
     * Chronical ID du texte lié
     * @type {string}
     * @memberof LienModification
     */
    'textCid'?: string;
    /**
     * Titre du texte lié
     * @type {string}
     * @memberof LienModification
     */
    'textTitle'?: string;
    /**
     * Numéro de l\'article lié
     * @type {string}
     * @memberof LienModification
     */
    'articleNum'?: string;
    /**
     * Sens de la modification
     * @type {string}
     * @memberof LienModification
     */
    'linkOrientation'?: string;
    /**
     * Identifiant de l\'article lié
     * @type {string}
     * @memberof LienModification
     */
    'articleId'?: string;
    /**
     * Date de début de la cible
     * @type {string}
     * @memberof LienModification
     */
    'dateDebutCible'?: string;
    /**
     * Date de publication du texte lié
     * @type {string}
     * @memberof LienModification
     */
    'datePubliTexte'?: string;
}
/**
 * Objet représentant un lien vers un texte
 * @export
 * @interface LienTxt
 */
export interface LienTxt {
    /**
     * Numéro d\'ordre
     * @type {number}
     * @memberof LienTxt
     */
    'ordre'?: number;
    /**
     * Titre
     * @type {string}
     * @memberof LienTxt
     */
    'titre'?: string;
    /**
     * Émetteur
     * @type {string}
     * @memberof LienTxt
     */
    'emetteur'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof LienTxt
     */
    'nature'?: string;
    /**
     * Autorité lié au texte
     * @type {string}
     * @memberof LienTxt
     */
    'autorite'?: string;
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof LienTxt
     */
    'id'?: string;
    /**
     * Etat juridique du texte
     * @type {string}
     * @memberof LienTxt
     */
    'etat'?: string;
    /**
     * Dernière date de modification du texte
     * @type {string}
     * @memberof LienTxt
     */
    'dateModif'?: string;
    /**
     * Numéro de séquence
     * @type {number}
     * @memberof LienTxt
     */
    'numSequence'?: number;
    /**
     * Ministère lié au texte
     * @type {string}
     * @memberof LienTxt
     */
    'ministere'?: string;
}
/**
 * Objet représentant un lien vers un autre élément
 * @export
 * @interface LiensRelatifsDTO
 */
export interface LiensRelatifsDTO {
    /**
     * Date pour création du lien
     * @type {string}
     * @memberof LiensRelatifsDTO
     */
    'dateVigeur'?: string;
    /**
     * Nature de texte de l\'élément lié
     * @type {string}
     * @memberof LiensRelatifsDTO
     */
    'nature'?: LiensRelatifsDTONatureEnum;
    /**
     * Chronical ID du parent de l\'élément lié. (Renseigné si besoin pour créer le lien vers l\'élément)
     * @type {string}
     * @memberof LiensRelatifsDTO
     */
    'cidParent'?: string;
    /**
     * Nom de l\'élément lié
     * @type {string}
     * @memberof LiensRelatifsDTO
     */
    'name'?: string;
    /**
     * Identifiant de l\'élément lié
     * @type {string}
     * @memberof LiensRelatifsDTO
     */
    'id'?: string;
    /**
     * Chronical ID du texte de l\'élément lié
     * @type {string}
     * @memberof LiensRelatifsDTO
     */
    'cidText'?: string;
}

export const LiensRelatifsDTONatureEnum = {
    Loda: 'LODA',
    Jorf: 'JORF',
    Code: 'CODE',
    Kali: 'KALI',
    Jorfcont: 'JORFCONT'
} as const;

export type LiensRelatifsDTONatureEnum = typeof LiensRelatifsDTONatureEnum[keyof typeof LiensRelatifsDTONatureEnum];

/**
 * Objet représentant un modificateur
 * @export
 * @interface ModificateurDTO
 */
export interface ModificateurDTO {
    /**
     * Identifiant
     * @type {string}
     * @memberof ModificateurDTO
     */
    'id'?: string;
    /**
     * Identifiant de l\'élément parent du modificateur (texte/section ...)
     * @type {string}
     * @memberof ModificateurDTO
     */
    'idParent'?: string;
    /**
     * Identifiant du texte du modificateur
     * @type {string}
     * @memberof ModificateurDTO
     */
    'idText'?: string;
    /**
     * Nature
     * @type {string}
     * @memberof ModificateurDTO
     */
    'nature'?: ModificateurDTONatureEnum;
    /**
     * Titre du modificateur
     * @type {string}
     * @memberof ModificateurDTO
     */
    'name'?: string;
}

export const ModificateurDTONatureEnum = {
    Loda: 'LODA',
    Jorf: 'JORF',
    Code: 'CODE',
    Kali: 'KALI',
    Jorfcont: 'JORFCONT'
} as const;

export type ModificateurDTONatureEnum = typeof ModificateurDTONatureEnum[keyof typeof ModificateurDTONatureEnum];

/**
 * Objet représentant une modification
 * @export
 * @interface ModificationDTO
 */
export interface ModificationDTO {
    /**
     * Type de modification
     * @type {string}
     * @memberof ModificationDTO
     */
    'type'?: ModificationDTOTypeEnum;
    /**
     * 
     * @type {ModificateurDTO}
     * @memberof ModificationDTO
     */
    'modificateur'?: ModificateurDTO;
}

export const ModificationDTOTypeEnum = {
    Creation: 'CREATION',
    Codification: 'CODIFICATION',
    Modification: 'MODIFICATION',
    Transfert: 'TRANSFERT',
    Abrogation: 'ABROGATION',
    Annulation: 'ANNULATION',
    Peremption: 'PEREMPTION',
    Disjonction: 'DISJONCTION',
    Rectification: 'RECTIFICATION',
    Substitution: 'SUBSTITUTION',
    Deplace: 'DEPLACE',
    Versement: 'VERSEMENT',
    Denonciation: 'DENONCIATION',
    Remplacement: 'REMPLACEMENT',
    Extension: 'EXTENSION',
    Elargissement: 'ELARGISSEMENT'
} as const;

export type ModificationDTOTypeEnum = typeof ModificationDTOTypeEnum[keyof typeof ModificationDTOTypeEnum];

/**
 * Objet représentant un niveau dans l\'arborescence d\'un dossier législatif
 * @export
 * @interface Niveau
 */
export interface Niveau {
    /**
     * Identifiant du niveau
     * @type {string}
     * @memberof Niveau
     */
    'id'?: string;
    /**
     * Libellé
     * @type {string}
     * @memberof Niveau
     */
    'libelle'?: string;
    /**
     * liste des niveaux enfants
     * @type {Array<Niveau>}
     * @memberof Niveau
     */
    'niveaux'?: Array<Niveau>;
    /**
     * Liste des liens du niveau
     * @type {Array<Lien>}
     * @memberof Niveau
     */
    'liens'?: Array<Lien>;
}
/**
 * Objet représentant le détail d\'un jurinome
 * @export
 * @interface Nomenclature
 */
export interface Nomenclature {
    /**
     * titre du juritext
     * @type {string}
     * @memberof Nomenclature
     */
    'titreJuritext'?: string;
    /**
     * nuveau du jurinome
     * @type {number}
     * @memberof Nomenclature
     */
    'niveau'?: number;
    /**
     * arborescent
     * @type {string}
     * @memberof Nomenclature
     */
    'arbo'?: string;
    /**
     * le libelle de l\'arborescence
     * @type {string}
     * @memberof Nomenclature
     */
    'libelleArbo'?: string;
    /**
     * Référence technique permettant d\'identifier la date d\'injection
     * @type {string}
     * @memberof Nomenclature
     */
    'refInjection'?: string;
    /**
     * id du juritext
     * @type {string}
     * @memberof Nomenclature
     */
    'idJuritext'?: string;
    /**
     * id du jurinome
     * @type {string}
     * @memberof Nomenclature
     */
    'id'?: string;
    /**
     * le libelle du jurinome
     * @type {string}
     * @memberof Nomenclature
     */
    'libelleNiveau'?: string;
    /**
     * feuille
     * @type {boolean}
     * @memberof Nomenclature
     */
    'feuille'?: boolean;
    /**
     * Identifiant technique de l\'élément injecté
     * @type {string}
     * @memberof Nomenclature
     */
    'idTechInjection'?: string;
    /**
     * id du parent du jurinome
     * @type {string}
     * @memberof Nomenclature
     */
    'parent'?: string;
}
/**
 * Objet définissant le nœud parent, dans le chronolegi ou chronokali, sur lequel est appliquée une modification
 * @export
 * @interface ParentChronoDTO
 */
export interface ParentChronoDTO {
    /**
     * Identifiant unique de l\'élément
     * @type {string}
     * @memberof ParentChronoDTO
     */
    'id'?: string;
    /**
     * Date de début de la version du noeud impactée
     * @type {string}
     * @memberof ParentChronoDTO
     */
    'dateDebut'?: string;
    /**
     * 
     * @type {CibleChronoDTO}
     * @memberof ParentChronoDTO
     */
    'texteCible'?: CibleChronoDTO;
    /**
     * Nature/type du texte
     * @type {string}
     * @memberof ParentChronoDTO
     */
    'nature'?: ParentChronoDTONatureEnum;
    /**
     * Nom/titre du parent
     * @type {string}
     * @memberof ParentChronoDTO
     */
    'name'?: string;
    /**
     * Chronical ID de l\'élément
     * @type {string}
     * @memberof ParentChronoDTO
     */
    'cid'?: string;
    /**
     * Map listant les sections ciblées par les modifications. La clé correspond à l\'ID de la section cible.
     * @type {{ [key: string]: CibleChronoDTO; }}
     * @memberof ParentChronoDTO
     */
    'sectionsCibles'?: { [key: string]: CibleChronoDTO; };
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof ParentChronoDTO
     */
    'cidText'?: string;
    /**
     * Map listant les articles ciblés par les modifications. La clé correspond à l\'ID de l\'article cible.
     * @type {{ [key: string]: CibleChronoDTO; }}
     * @memberof ParentChronoDTO
     */
    'articlesCibles'?: { [key: string]: CibleChronoDTO; };
}

export const ParentChronoDTONatureEnum = {
    Loda: 'LODA',
    Jorf: 'JORF',
    Code: 'CODE',
    Kali: 'KALI',
    Jorfcont: 'JORFCONT'
} as const;

export type ParentChronoDTONatureEnum = typeof ParentChronoDTONatureEnum[keyof typeof ParentChronoDTONatureEnum];

/**
 * 
 * @export
 * @interface PdfMetadata
 */
export interface PdfMetadata {
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'complementNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'num'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'displaySize'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'pathToFile'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'datePubli'?: string;
    /**
     * 
     * @type {string}
     * @memberof PdfMetadata
     */
    'origine'?: string;
    /**
     * 
     * @type {number}
     * @memberof PdfMetadata
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface QuestionsEcritesParlementairesListRequest
 */
export interface QuestionsEcritesParlementairesListRequest {
    /**
     * Nombre de résultats par page (max 100)
     * @type {number}
     * @memberof QuestionsEcritesParlementairesListRequest
     */
    'pageSize': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionsEcritesParlementairesListRequest
     */
    'periodePublication'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionsEcritesParlementairesListRequest
     */
    'secondSortValue'?: string;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof QuestionsEcritesParlementairesListRequest
     */
    'pageNumber': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionsEcritesParlementairesListRequest
     */
    'sortValue'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionsEcritesParlementairesListRequest
     */
    'parlementTypes'?: Array<string>;
}
/**
 * Résultat d\'une requête pour lister les questions écrites parlementaires.
 * @export
 * @interface QuestionsEcritesParlementairesListResponse
 */
export interface QuestionsEcritesParlementairesListResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof QuestionsEcritesParlementairesListResponse
     */
    'executionTime'?: number;
    /**
     * Nombre total de résultats
     * @type {number}
     * @memberof QuestionsEcritesParlementairesListResponse
     */
    'totalResultNumber'?: number;
    /**
     * Liste des résultats de la page
     * @type {Array<EsQuestionsEcritesParlementaires>}
     * @memberof QuestionsEcritesParlementairesListResponse
     */
    'results'?: Array<EsQuestionsEcritesParlementaires>;
    /**
     * 
     * @type {Facet}
     * @memberof QuestionsEcritesParlementairesListResponse
     */
    'typesParlement'?: Facet;
    /**
     * Taille du fichier avec son unité
     * @type {string}
     * @memberof QuestionsEcritesParlementairesListResponse
     */
    'displaySize'?: string;
}
/**
 * Objet permettant de créer une recherche
 * @export
 * @interface RechercheSpecifiqueDTO
 */
export interface RechercheSpecifiqueDTO {
    /**
     * Opérateur entre les champs de recherche
     * @type {string}
     * @memberof RechercheSpecifiqueDTO
     */
    'operateur': RechercheSpecifiqueDTOOperateurEnum;
    /**
     * Nombre d\'éléments par page (max=100)
     * @type {number}
     * @memberof RechercheSpecifiqueDTO
     */
    'pageSize': number;
    /**
     * Liste des filtres à appliquer. La requête est effectuée automatiquement avec un opérateur ET entre les filtres listés.
     * @type {Array<FiltreDTO>}
     * @memberof RechercheSpecifiqueDTO
     */
    'filtres'?: Array<FiltreDTO>;
    /**
     * Tri des éléments trouvés (Les tris possibles dépendent du fonds recherché)
     * @type {string}
     * @memberof RechercheSpecifiqueDTO
     */
    'sort': string;
    /**
     * Tri des éléments trouvés (Les tris possibles dépendent du fonds recherché)
     * @type {string}
     * @memberof RechercheSpecifiqueDTO
     */
    'secondSort'?: string;
    /**
     * Type de pagination. Spécifique pour les recherches dans les articles d\'un texte, dans les autres cas la valeur sera toujours DEFAULT. Lors de la navigation dans plusieurs pages, il est nécessaire de passer la valeur reçue dans la réponse précédente.
     * @type {string}
     * @memberof RechercheSpecifiqueDTO
     */
    'typePagination': RechercheSpecifiqueDTOTypePaginationEnum;
    /**
     * Déterminer s\'il s\'agit d\'une recherche avancée
     * @type {boolean}
     * @memberof RechercheSpecifiqueDTO
     */
    'fromAdvancedRecherche'?: boolean;
    /**
     * Numéro de la page à consulter
     * @type {number}
     * @memberof RechercheSpecifiqueDTO
     */
    'pageNumber': number;
    /**
     * Liste des champs dans lesquels appliquer la recherche
     * @type {Array<ChampDTO>}
     * @memberof RechercheSpecifiqueDTO
     */
    'champs': Array<ChampDTO>;
}

export const RechercheSpecifiqueDTOOperateurEnum = {
    Et: 'ET',
    Ou: 'OU'
} as const;

export type RechercheSpecifiqueDTOOperateurEnum = typeof RechercheSpecifiqueDTOOperateurEnum[keyof typeof RechercheSpecifiqueDTOOperateurEnum];
export const RechercheSpecifiqueDTOTypePaginationEnum = {
    Defaut: 'DEFAUT',
    Article: 'ARTICLE'
} as const;

export type RechercheSpecifiqueDTOTypePaginationEnum = typeof RechercheSpecifiqueDTOTypePaginationEnum[keyof typeof RechercheSpecifiqueDTOTypePaginationEnum];

/**
 * Objet définissant le regroupement de plusieurs versions
 * @export
 * @interface RegroupementDTO
 */
export interface RegroupementDTO {
    /**
     * Map listant les versions dans l\'ordre antéchronologique.  La clé correspond à la date de la version
     * @type {{ [key: string]: VersionDTO; }}
     * @memberof RegroupementDTO
     */
    'versions'?: { [key: string]: VersionDTO; };
    /**
     * Titre du regroupement
     * @type {string}
     * @memberof RegroupementDTO
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RegroupementDTO
     */
    'detailLoaded'?: boolean;
}
/**
 * requête de récupération des liens de citation d\'un article
 * @export
 * @interface RelatedLinksArticleRequest
 */
export interface RelatedLinksArticleRequest {
    /**
     * Identifiant de l\'article
     * @type {string}
     * @memberof RelatedLinksArticleRequest
     */
    'articleId': string;
}
/**
 * Réponse d\'une requête de récupération des liens de citation d\'un article
 * @export
 * @interface RelatedLinksArticleResponse
 */
export interface RelatedLinksArticleResponse {
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof RelatedLinksArticleResponse
     */
    'executionTime'?: number;
    /**
     * Liste des liens vers les éléments que notre article cite
     * @type {Array<LiensRelatifsDTO>}
     * @memberof RelatedLinksArticleResponse
     */
    'liensCite'?: Array<LiensRelatifsDTO>;
    /**
     * Liste des liens vers les éléments qui citent notre article
     * @type {Array<LiensRelatifsDTO>}
     * @memberof RelatedLinksArticleResponse
     */
    'liensCitePar'?: Array<LiensRelatifsDTO>;
}
/**
 * Requête de récupération des articles, ayant un Chronical ID différent et portant le même numéro dans toutes les versions du texte
 * @export
 * @interface SameNumArticleRequest
 */
export interface SameNumArticleRequest {
    /**
     * Date de référence
     * @type {string}
     * @memberof SameNumArticleRequest
     */
    'date': string;
    /**
     * Chronical ID de l\'article
     * @type {string}
     * @memberof SameNumArticleRequest
     */
    'articleCid': string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof SameNumArticleRequest
     */
    'textCid': string;
    /**
     * Numéro de l\'article
     * @type {string}
     * @memberof SameNumArticleRequest
     */
    'articleNum': string;
}
/**
 * 
 * @export
 * @interface SearchAdditionalResult
 */
export interface SearchAdditionalResult {
    /**
     * 
     * @type {string}
     * @memberof SearchAdditionalResult
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SearchAdditionalResult
     */
    'properties'?: { [key: string]: string; };
}
/**
 * Résultat d\'une requête de récupération des versions d\'un article
 * @export
 * @interface SearchCanonicalArticleVersionResponse
 */
export interface SearchCanonicalArticleVersionResponse {
    /**
     * Liste des versions d\'articles
     * @type {Array<ArticleVersion>}
     * @memberof SearchCanonicalArticleVersionResponse
     */
    'articleVersions'?: Array<ArticleVersion>;
}
/**
 * Requête de récupération de la version d\'un texte (et d\'une section) la plus proche d\'une date demandée
 * @export
 * @interface SearchCanonicalVersionRequest
 */
export interface SearchCanonicalVersionRequest {
    /**
     * Chronical ID de la section
     * @type {string}
     * @memberof SearchCanonicalVersionRequest
     */
    'cidSection'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof SearchCanonicalVersionRequest
     */
    'cidText': string;
    /**
     * Date de référence pour la recherche
     * @type {string}
     * @memberof SearchCanonicalVersionRequest
     */
    'date': string;
}
/**
 * Résultat d\'une requête de récupération de la version canonique d\'un texte en fonction d\'une date
 * @export
 * @interface SearchCanonicalVersionResponse
 */
export interface SearchCanonicalVersionResponse {
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof SearchCanonicalVersionResponse
     */
    'cid'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof SearchCanonicalVersionResponse
     */
    'dateDebut'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof SearchCanonicalVersionResponse
     */
    'dateFin'?: string;
}
/**
 * 
 * @export
 * @interface SearchExtract
 */
export interface SearchExtract {
    /**
     * 
     * @type {string}
     * @memberof SearchExtract
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchExtract
     */
    'legalStatus'?: SearchExtractLegalStatusEnum;
    /**
     * Date de début
     * @type {string}
     * @memberof SearchExtract
     */
    'dateDebut'?: string;
    /**
     * Date de la version (date de début ou date de fin)
     * @type {string}
     * @memberof SearchExtract
     */
    'dateVersion'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchExtract
     */
    'values'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SearchExtract
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchExtract
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchExtract
     */
    'num'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchExtract
     */
    'searchFieldName'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof SearchExtract
     */
    'dateFin'?: string;
}

export const SearchExtractLegalStatusEnum = {
    Vigueur: 'VIGUEUR',
    AbrogeDiff: 'ABROGE_DIFF',
    VigueurDiff: 'VIGUEUR_DIFF',
    VigueurEten: 'VIGUEUR_ETEN',
    VigueurNonEten: 'VIGUEUR_NON_ETEN',
    Abroge: 'ABROGE',
    Perime: 'PERIME',
    Annule: 'ANNULE',
    Modifie: 'MODIFIE',
    Disjoint: 'DISJOINT',
    Substitue: 'SUBSTITUE',
    Transfere: 'TRANSFERE',
    Initiale: 'INITIALE',
    ModifieMortNe: 'MODIFIE_MORT_NE',
    SansEtat: 'SANS_ETAT',
    Denonce: 'DENONCE',
    Remplace: 'REMPLACE'
} as const;

export type SearchExtractLegalStatusEnum = typeof SearchExtractLegalStatusEnum[keyof typeof SearchExtractLegalStatusEnum];

/**
 * Requête de récupération de la version d\'un texte (et d\'une section) la plus proche d\'une date demandée
 * @export
 * @interface SearchNearestVersionRequest
 */
export interface SearchNearestVersionRequest {
    /**
     * Chronical ID de la section
     * @type {string}
     * @memberof SearchNearestVersionRequest
     */
    'cidSection'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof SearchNearestVersionRequest
     */
    'cidText': string;
    /**
     * Date de référence pour la recherche
     * @type {string}
     * @memberof SearchNearestVersionRequest
     */
    'date': string;
}
/**
 * Résultat d\'une requête de récupération de la version la plus proche d\'un texte en fonction d\'une date
 * @export
 * @interface SearchNearestVersionResponse
 */
export interface SearchNearestVersionResponse {
    /**
     * 
     * @type {SearchTitle}
     * @memberof SearchNearestVersionResponse
     */
    'title'?: SearchTitle;
    /**
     * Titre de la version de la section trouvée si une section est recherchée
     * @type {string}
     * @memberof SearchNearestVersionResponse
     */
    'sectionTitle'?: string;
}
/**
 * Requête paginée de recherche
 * @export
 * @interface SearchRequestDTO
 */
export interface SearchRequestDTO {
    /**
     * Fonds sur lequel appliquer la recherche. Pour rechercher dans tous les fonds, il faut définir la valeur ALL. Pour les fonds LODA et CODE il existe deux types de recherche : la recherche par date (_DATE) de version ou la recherche par état juridique (_ETAT)
     * @type {string}
     * @memberof SearchRequestDTO
     */
    'fond': SearchRequestDTOFondEnum;
    /**
     * Liste des natures gardés en cache Java
     * @type {{ [key: string]: Array<string>; }}
     * @memberof SearchRequestDTO
     */
    'cachedData'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {RechercheSpecifiqueDTO}
     * @memberof SearchRequestDTO
     */
    'recherche': RechercheSpecifiqueDTO;
}

export const SearchRequestDTOFondEnum = {
    Jorf: 'JORF',
    Cnil: 'CNIL',
    Cetat: 'CETAT',
    Juri: 'JURI',
    Jufi: 'JUFI',
    Constit: 'CONSTIT',
    Kali: 'KALI',
    CodeDate: 'CODE_DATE',
    CodeEtat: 'CODE_ETAT',
    LodaDate: 'LODA_DATE',
    LodaEtat: 'LODA_ETAT',
    All: 'ALL',
    Circ: 'CIRC',
    Acco: 'ACCO'
} as const;

export type SearchRequestDTOFondEnum = typeof SearchRequestDTOFondEnum[keyof typeof SearchRequestDTOFondEnum];

/**
 * Page des résultats demandée lors d\'une recherche paginée
 * @export
 * @interface SearchResponseDTO
 */
export interface SearchResponseDTO {
    /**
     * Type de pagination. Spécifique pour les recherches dans les articles d\'un texte spécifique, dans les autres cas la valeur sera toujours DEFAULT.
     * @type {string}
     * @memberof SearchResponseDTO
     */
    'typePagination'?: SearchResponseDTOTypePaginationEnum;
    /**
     * Liste des résultats de la page
     * @type {Array<SearchResult>}
     * @memberof SearchResponseDTO
     */
    'results'?: Array<SearchResult>;
    /**
     * 
     * @type {number}
     * @memberof SearchResponseDTO
     */
    'totalArticleResultNumber'?: number;
    /**
     * Description fusion
     * @type {string}
     * @memberof SearchResponseDTO
     */
    'descriptionFusionHtml'?: string;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof SearchResponseDTO
     */
    'executionTime'?: number;
    /**
     * Nombre de résultats
     * @type {number}
     * @memberof SearchResponseDTO
     */
    'totalResultNumber'?: number;
    /**
     * Liste des facettes liées
     * @type {Array<Facet>}
     * @memberof SearchResponseDTO
     */
    'facets'?: Array<Facet>;
}

export const SearchResponseDTOTypePaginationEnum = {
    Defaut: 'DEFAUT',
    Article: 'ARTICLE'
} as const;

export type SearchResponseDTOTypePaginationEnum = typeof SearchResponseDTOTypePaginationEnum[keyof typeof SearchResponseDTOTypePaginationEnum];

/**
 * Objet représentant un résultat de recherche
 * @export
 * @interface SearchResult
 */
export interface SearchResult {
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchResult
     */
    'appellations'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResult
     */
    'moreArticle'?: boolean;
    /**
     * Date diffusion
     * @type {string}
     * @memberof SearchResult
     */
    'dateDiffusion'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchResult
     */
    'autreResume'?: Array<string>;
    /**
     * Date de signature
     * @type {string}
     * @memberof SearchResult
     */
    'dateSignature'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'raisonSociale'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'nature'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'jorfText'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'origin'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchResult
     */
    'resumePrincipal'?: Array<string>;
    /**
     * 
     * @type {Array<SearchTitle>}
     * @memberof SearchResult
     */
    'titles'?: Array<SearchTitle>;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'nor'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchResult
     */
    'themes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'sizeAttachment'?: string;
    /**
     * Date utile
     * @type {string}
     * @memberof SearchResult
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'idcc'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResult
     */
    'conforme'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'num'?: string;
    /**
     * Date de publication
     * @type {string}
     * @memberof SearchResult
     */
    'datePublication'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'numParution'?: string;
    /**
     * 
     * @type {Array<SearchSection>}
     * @memberof SearchResult
     */
    'sections'?: Array<SearchSection>;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'idAttachment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'descriptionFusionHtml'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'etat'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchResult
     */
    'motsCles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResult
     */
    'reference'?: string;
    /**
     * 
     * @type {{ [key: string]: SearchAdditionalResult; }}
     * @memberof SearchResult
     */
    'additionalResult'?: { [key: string]: SearchAdditionalResult; };
    /**
     * 
     * @type {Array<DossierLegislatif>}
     * @memberof SearchResult
     */
    'dossiersLegislatifs'?: Array<DossierLegislatif>;
}
/**
 * 
 * @export
 * @interface SearchSection
 */
export interface SearchSection {
    /**
     * 
     * @type {string}
     * @memberof SearchSection
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchSection
     */
    'legalStatus'?: SearchSectionLegalStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchSection
     */
    'title'?: string;
    /**
     * Date de version
     * @type {string}
     * @memberof SearchSection
     */
    'dateVersion'?: string;
    /**
     * 
     * @type {Array<SearchExtract>}
     * @memberof SearchSection
     */
    'extracts'?: Array<SearchExtract>;
}

export const SearchSectionLegalStatusEnum = {
    Vigueur: 'VIGUEUR',
    AbrogeDiff: 'ABROGE_DIFF',
    VigueurDiff: 'VIGUEUR_DIFF',
    VigueurEten: 'VIGUEUR_ETEN',
    VigueurNonEten: 'VIGUEUR_NON_ETEN',
    Abroge: 'ABROGE',
    Perime: 'PERIME',
    Annule: 'ANNULE',
    Modifie: 'MODIFIE',
    Disjoint: 'DISJOINT',
    Substitue: 'SUBSTITUE',
    Transfere: 'TRANSFERE',
    Initiale: 'INITIALE',
    ModifieMortNe: 'MODIFIE_MORT_NE',
    SansEtat: 'SANS_ETAT',
    Denonce: 'DENONCE',
    Remplace: 'REMPLACE'
} as const;

export type SearchSectionLegalStatusEnum = typeof SearchSectionLegalStatusEnum[keyof typeof SearchSectionLegalStatusEnum];

/**
 * Objet décrivant la version d\'un texte
 * @export
 * @interface SearchTitle
 */
export interface SearchTitle {
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof SearchTitle
     */
    'id'?: string;
    /**
     * Date de fin de la version
     * @type {string}
     * @memberof SearchTitle
     */
    'endDate'?: string;
    /**
     * Nature du texte
     * @type {string}
     * @memberof SearchTitle
     */
    'nature'?: string;
    /**
     * Etat juridique de la version
     * @type {string}
     * @memberof SearchTitle
     */
    'legalStatus'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof SearchTitle
     */
    'cid'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof SearchTitle
     */
    'title'?: string;
    /**
     * Date de début de la version
     * @type {string}
     * @memberof SearchTitle
     */
    'startDate'?: string;
}
/**
 * 
 * @export
 * @interface Section
 */
export interface Section {
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'refInjection'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'id'?: string;
    /**
     * 
     * @type {Context}
     * @memberof Section
     */
    'context'?: Context;
    /**
     * 
     * @type {Array<StructureLienArticle>}
     * @memberof Section
     */
    'liensArticle'?: Array<StructureLienArticle>;
    /**
     * 
     * @type {Array<Lien>}
     * @memberof Section
     */
    'liensModification'?: Array<Lien>;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'cid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'dateDebut'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'commentaire'?: string;
    /**
     * 
     * @type {Array<StructureLienSection>}
     * @memberof Section
     */
    'liensSection'?: Array<StructureLienSection>;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'notaHtml'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'nota'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'dateFin'?: string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'idTechInjection'?: string;
}
/**
 * Requête pour récupérer une section par son Chronical CID
 * @export
 * @interface SectionCidRequest
 */
export interface SectionCidRequest {
    /**
     * Chronical CID de la section
     * @type {string}
     * @memberof SectionCidRequest
     */
    'cid': string;
}
/**
 * Réponse à une requête de récupération des liens de concordance d\'un article ou des articles avec le même numéro
 * @export
 * @interface SectionsRevisionArticleResponse
 */
export interface SectionsRevisionArticleResponse {
    /**
     * Liste des anciens textes liés à l\'article
     * @type {Array<ArticleDTO>}
     * @memberof SectionsRevisionArticleResponse
     */
    'oldTexts'?: Array<ArticleDTO>;
    /**
     * Temps d\'exécution
     * @type {number}
     * @memberof SectionsRevisionArticleResponse
     */
    'executionTime'?: number;
    /**
     * Liste des nouveaux textes liés à l\'article
     * @type {Array<ArticleDTO>}
     * @memberof SectionsRevisionArticleResponse
     */
    'newTexts'?: Array<ArticleDTO>;
}
/**
 * Objet représentant un signataire KALI
 * @export
 * @interface SignataireKali
 */
export interface SignataireKali {
    /**
     * Fait A
     * @type {string}
     * @memberof SignataireKali
     */
    'faitA'?: string;
    /**
     * Patronat
     * @type {string}
     * @memberof SignataireKali
     */
    'patron'?: string;
    /**
     * Adhésion
     * @type {string}
     * @memberof SignataireKali
     */
    'adhesion'?: string;
    /**
     * Signataire extérieur
     * @type {string}
     * @memberof SignataireKali
     */
    'signExt'?: string;
    /**
     * Dénonciation
     * @type {string}
     * @memberof SignataireKali
     */
    'denonciation'?: string;
    /**
     * Exécution
     * @type {string}
     * @memberof SignataireKali
     */
    'execution'?: string;
    /**
     * Syndicat
     * @type {string}
     * @memberof SignataireKali
     */
    'syndic'?: string;
}
/**
 * 
 * @export
 * @interface StructureLienArticle
 */
export interface StructureLienArticle {
    /**
     * 
     * @type {string}
     * @memberof StructureLienArticle
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienArticle
     */
    'etat'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienArticle
     */
    'dateDebut'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienArticle
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienArticle
     */
    'dateFin'?: string;
}
/**
 * 
 * @export
 * @interface StructureLienSection
 */
export interface StructureLienSection {
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'dateDebut'?: string;
    /**
     * 
     * @type {number}
     * @memberof StructureLienSection
     */
    'ordre'?: number;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'renvoi'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'etat'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'cid'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'commentaire'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'renvoiNum'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructureLienSection
     */
    'dateFin'?: string;
}
/**
 * Objet représentant la structure d\'un conteneur
 * @export
 * @interface StructureTxt
 */
export interface StructureTxt {
    /**
     * Liste des sections de premier niveau dans le conteneur
     * @type {Array<Tms>}
     * @memberof StructureTxt
     */
    'tms'?: Array<Tms>;
    /**
     * Liste des liens vers les textes de premier niveau dans le conteneur
     * @type {Array<LienTxt>}
     * @memberof StructureTxt
     */
    'liens'?: Array<LienTxt>;
}
/**
 * Réponse à une requête de suggestion pour les accords d\'entreprises
 * @export
 * @interface SuggestAccoResponse
 */
export interface SuggestAccoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuggestAccoResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof SuggestAccoResponse
     */
    'totalResultNumber'?: number;
    /**
     * Liste des suggestions
     * @type {{ [key: string]: { [key: string]: SuggestAccoValue; }; }}
     * @memberof SuggestAccoResponse
     */
    'results'?: { [key: string]: { [key: string]: SuggestAccoValue; }; };
}
/**
 * Objet représentant une suggestion constituée d\'un SIRET + raison sociale d\'une entreprise pour les accords d\'entreprises
 * @export
 * @interface SuggestAccoValue
 */
export interface SuggestAccoValue {
    /**
     * SIRET
     * @type {string}
     * @memberof SuggestAccoValue
     */
    'siret'?: string;
    /**
     * Raison sociale
     * @type {string}
     * @memberof SuggestAccoValue
     */
    'raisonSociale'?: string;
}
/**
 * Requête de suggestion d\'une recherche textuelle dans un fond
 * @export
 * @interface SuggestPdcRequest
 */
export interface SuggestPdcRequest {
    /**
     * 
     * @type {string}
     * @memberof SuggestPdcRequest
     */
    'fond'?: string;
    /**
     * Texte à rechercher
     * @type {string}
     * @memberof SuggestPdcRequest
     */
    'searchText'?: string;
    /**
     * 
     * @type {string}
     * @memberof SuggestPdcRequest
     */
    'origin'?: string;
}
/**
 * Requête de suggestion d\'une recherche textuelle
 * @export
 * @interface SuggestRequest
 */
export interface SuggestRequest {
    /**
     * Texte à rechercher
     * @type {string}
     * @memberof SuggestRequest
     */
    'searchText'?: string;
}
/**
 * Résultat de recherche de suggestions. Retourne des titres de texte/section/article
 * @export
 * @interface SuggestResponse
 */
export interface SuggestResponse {
    /**
     * 
     * @type {number}
     * @memberof SuggestResponse
     */
    'executionTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof SuggestResponse
     */
    'totalResultNumber'?: number;
    /**
     * Liste des suggestions retournées. La clé représente l\'id du texte/section/article
     * @type {{ [key: string]: { [key: string]: SuggestValue; }; }}
     * @memberof SuggestResponse
     */
    'results'?: { [key: string]: { [key: string]: SuggestValue; }; };
}
/**
 * Requête de suggestion d\'une recherche textuelle dans un ou plusieurs fonds
 * @export
 * @interface SuggestSupplyRequest
 */
export interface SuggestSupplyRequest {
    /**
     * Texte à rechercher
     * @type {string}
     * @memberof SuggestSupplyRequest
     */
    'searchText'?: string;
    /**
     * Liste des fonds dans lesquels exécuter la recherche pour la suggestion
     * @type {Array<string>}
     * @memberof SuggestSupplyRequest
     */
    'supplies'?: Array<SuggestSupplyRequestSuppliesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof SuggestSupplyRequest
     */
    'documentsDits'?: boolean;
}

export const SuggestSupplyRequestSuppliesEnum = {
    All: 'ALL',
    AllSuggest: 'ALL_SUGGEST',
    LodaList: 'LODA_LIST',
    CodeList: 'CODE_LIST',
    CodeReleaseDate: 'CODE_RELEASE_DATE',
    CodeReleaseDateSuggest: 'CODE_RELEASE_DATE_SUGGEST',
    CodeLegalStatus: 'CODE_LEGAL_STATUS',
    LodaReleaseDate: 'LODA_RELEASE_DATE',
    LodaReleaseDateSuggest: 'LODA_RELEASE_DATE_SUGGEST',
    LodaLegalStatus: 'LODA_LEGAL_STATUS',
    Kali: 'KALI',
    KaliText: 'KALI_TEXT',
    Constit: 'CONSTIT',
    Cetat: 'CETAT',
    Jufi: 'JUFI',
    Juri: 'JURI',
    Jorf: 'JORF',
    JorfSuggest: 'JORF_SUGGEST',
    Cnil: 'CNIL',
    Article: 'ARTICLE',
    Circ: 'CIRC',
    Acco: 'ACCO',
    Pdf: 'PDF'
} as const;

export type SuggestSupplyRequestSuppliesEnum = typeof SuggestSupplyRequestSuppliesEnum[keyof typeof SuggestSupplyRequestSuppliesEnum];

/**
 * Objet représentant une suggestion
 * @export
 * @interface SuggestValue
 */
export interface SuggestValue {
    /**
     * Titre à afficher
     * @type {string}
     * @memberof SuggestValue
     */
    'label'?: string;
    /**
     * Appellations
     * @type {Array<string>}
     * @memberof SuggestValue
     */
    'appellations'?: Array<string>;
    /**
     * idTexte
     * @type {string}
     * @memberof SuggestValue
     */
    'idTexte'?: string;
    /**
     * Date de la version retournée par la suggestion
     * @type {string}
     * @memberof SuggestValue
     */
    'dateVersion'?: string;
    /**
     * Nature de l\'élément lié
     * @type {string}
     * @memberof SuggestValue
     */
    'nature'?: string;
    /**
     * Section
     * @type {string}
     * @memberof SuggestValue
     */
    'section'?: string;
    /**
     * Identifiant du texte/section/article
     * @type {string}
     * @memberof SuggestValue
     */
    'id'?: string;
    /**
     * Origine
     * @type {string}
     * @memberof SuggestValue
     */
    'origin'?: string;
}
/**
 * Objet représentant un syndicat
 * @export
 * @interface Syndicat
 */
export interface Syndicat {
    /**
     * Libellé
     * @type {string}
     * @memberof Syndicat
     */
    'libelle'?: string;
    /**
     * Code
     * @type {string}
     * @memberof Syndicat
     */
    'code'?: string;
}
/**
 * Requête de récupération des tables annuelles
 * @export
 * @interface TableRequest
 */
export interface TableRequest {
    /**
     * Année de fin
     * @type {number}
     * @memberof TableRequest
     */
    'endYear': number;
    /**
     * Année de début
     * @type {number}
     * @memberof TableRequest
     */
    'startYear'?: number;
}
/**
 * Objet représentant les métadonnées d\'une version d\'un texte
 * @export
 * @interface TextTitle
 */
export interface TextTitle {
    /**
     * Appellations
     * @type {Array<string>}
     * @memberof TextTitle
     */
    'appellations'?: Array<string>;
    /**
     * Visas
     * @type {string}
     * @memberof TextTitle
     */
    'visas'?: string;
    /**
     * Identifiant
     * @type {string}
     * @memberof TextTitle
     */
    'id'?: string;
    /**
     * Notice
     * @type {string}
     * @memberof TextTitle
     */
    'notice'?: string;
    /**
     * Date de fin
     * @type {string}
     * @memberof TextTitle
     */
    'dateFin'?: string;
    /**
     * Date de la version courante du texte
     * @type {string}
     * @memberof TextTitle
     */
    'dateTexteComputed'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof TextTitle
     */
    'titre'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof TextTitle
     */
    'dateDebut'?: string;
    /**
     * Nature du texte
     * @type {string}
     * @memberof TextTitle
     */
    'nature'?: string;
    /**
     * Travaux préparatoires
     * @type {string}
     * @memberof TextTitle
     */
    'travauxPreparatoires'?: string;
    /**
     * Date de publication de la version courante
     * @type {string}
     * @memberof TextTitle
     */
    'datePubliComputed'?: string;
    /**
     * Portée Géographique
     * @type {string}
     * @memberof TextTitle
     */
    'appliGeo'?: string;
    /**
     * Signataires
     * @type {string}
     * @memberof TextTitle
     */
    'signataires'?: string;
    /**
     * Nota
     * @type {string}
     * @memberof TextTitle
     */
    'nota'?: string;
    /**
     * Numéro du texte
     * @type {string}
     * @memberof TextTitle
     */
    'num'?: string;
    /**
     * Liste des code de nomenclature
     * @type {Array<string>}
     * @memberof TextTitle
     */
    'codesNomenclatures'?: Array<string>;
    /**
     * Numéro de parution
     * @type {string}
     * @memberof TextTitle
     */
    'numParution'?: string;
    /**
     * Date du texte
     * @type {string}
     * @memberof TextTitle
     */
    'dateTexte'?: string;
    /**
     * Titre long
     * @type {string}
     * @memberof TextTitle
     */
    'titreLong'?: string;
    /**
     * ID référençant le code lié à l\'article cible.
     * @type {string}
     * @memberof TextTitle
     */
    'ancienId'?: string;
    /**
     * Origine de la publication
     * @type {string}
     * @memberof TextTitle
     */
    'originePubli'?: string;
    /**
     * Date de publication
     * @type {string}
     * @memberof TextTitle
     */
    'datePubli'?: string;
    /**
     * Chronical ID
     * @type {string}
     * @memberof TextTitle
     */
    'cid'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof TextTitle
     */
    'etat'?: string;
    /**
     * Numéro NOR
     * @type {string}
     * @memberof TextTitle
     */
    'nor'?: string;
    /**
     * Liste des dossiers législatifs
     * @type {Array<DossierLegislatif>}
     * @memberof TextTitle
     */
    'dossiersLegislatifs'?: Array<DossierLegislatif>;
}
/**
 * Objet représentant un lien vers un texte
 * @export
 * @interface TexteLien
 */
export interface TexteLien {
    /**
     * Date de signature
     * @type {string}
     * @memberof TexteLien
     */
    'dateSignaTexte'?: string;
    /**
     * Numéro
     * @type {string}
     * @memberof TexteLien
     */
    'num'?: string;
    /**
     * Titre
     * @type {string}
     * @memberof TexteLien
     */
    'title'?: string;
    /**
     * Nature du texte
     * @type {string}
     * @memberof TexteLien
     */
    'natureTexte'?: string;
    /**
     * Type de lien
     * @type {string}
     * @memberof TexteLien
     */
    'typeLien'?: string;
    /**
     * Identifiant
     * @type {string}
     * @memberof TexteLien
     */
    'id'?: string;
    /**
     * Numéro du texte
     * @type {string}
     * @memberof TexteLien
     */
    'numTexte'?: string;
    /**
     * NOR
     * @type {string}
     * @memberof TexteLien
     */
    'norTexte'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof TexteLien
     */
    'cidTexte'?: string;
    /**
     * Sens du type de lien
     * @type {string}
     * @memberof TexteLien
     */
    'sens'?: string;
    /**
     * Date de publication
     * @type {string}
     * @memberof TexteLien
     */
    'datePubliTexte'?: string;
}
/**
 * Objet représentant un texte de référence
 * @export
 * @interface TexteReference
 */
export interface TexteReference {
    /**
     * Texte de référence
     * @type {string}
     * @memberof TexteReference
     */
    'texteReference'?: string;
    /**
     * Lien vers le texte
     * @type {string}
     * @memberof TexteReference
     */
    'url'?: string;
}
/**
 * Objet représentant un texte simple
 * @export
 * @interface TexteSimple
 */
export interface TexteSimple {
    /**
     * Numéro de la loi déférée
     * @type {string}
     * @memberof TexteSimple
     */
    'numLoiDef'?: string;
    /**
     * Numéro du texte JO
     * @type {string}
     * @memberof TexteSimple
     */
    'numTexteJo'?: string;
    /**
     * Texte HTML de la notice
     * @type {string}
     * @memberof TexteSimple
     */
    'noticeHtml'?: string;
    /**
     * Texte HTML des signataires
     * @type {string}
     * @memberof TexteSimple
     */
    'signatairesHtml'?: string;
    /**
     * Liste des éléments de titrage
     * @type {Array<string>}
     * @memberof TexteSimple
     */
    'titrages'?: Array<string>;
    /**
     * Date de fin
     * @type {string}
     * @memberof TexteSimple
     */
    'dateFin'?: string;
    /**
     * Texte HTML des informations complémentaires
     * @type {Array<string>}
     * @memberof TexteSimple
     */
    'notaSectionsAafficher'?: Array<string>;
    /**
     * Condition de différé
     * @type {string}
     * @memberof TexteSimple
     */
    'conditionDiffere'?: string;
    /**
     * Nature de la délibération
     * @type {string}
     * @memberof TexteSimple
     */
    'natureDelib'?: string;
    /**
     * Commissaire
     * @type {string}
     * @memberof TexteSimple
     */
    'commissaire'?: string;
    /**
     * Ministere
     * @type {string}
     * @memberof TexteSimple
     */
    'ministere'?: string;
    /**
     * Contient la date du texte si elle existe (!= null && != 2999-01-01) sinon contient la date de publication  pour les texte
     * @type {string}
     * @memberof TexteSimple
     */
    'relevantDate'?: string;
    /**
     * Portée géographique
     * @type {string}
     * @memberof TexteSimple
     */
    'appliGeo'?: string;
    /**
     * Titre de la loi déférée
     * @type {string}
     * @memberof TexteSimple
     */
    'titreLoiDef'?: string;
    /**
     * Notas
     * @type {string}
     * @memberof TexteSimple
     */
    'nota'?: string;
    /**
     * ECLI
     * @type {string}
     * @memberof TexteSimple
     */
    'ecli'?: string;
    /**
     * provenance
     * @type {string}
     * @memberof TexteSimple
     */
    'provenance'?: string;
    /**
     * Emetteur
     * @type {string}
     * @memberof TexteSimple
     */
    'emetteur'?: string;
    /**
     * Alias ELI
     * @type {string}
     * @memberof TexteSimple
     */
    'idEliAlias'?: string;
    /**
     * Chronical ID du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'cid'?: string;
    /**
     * Travaux préparatoires
     * @type {string}
     * @memberof TexteSimple
     */
    'travauxPreparatoires'?: string;
    /**
     * Avocat général
     * @type {string}
     * @memberof TexteSimple
     */
    'avocatGl'?: string;
    /**
     * Liste des éléments de titrage
     * @type {Array<Titrage>}
     * @memberof TexteSimple
     */
    'titragesKey'?: Array<Titrage>;
    /**
     * Visas
     * @type {string}
     * @memberof TexteSimple
     */
    'visas'?: string;
    /**
     * Numéro BO
     * @type {string}
     * @memberof TexteSimple
     */
    'numeroBo'?: string;
    /**
     * 
     * @type {SignataireKali}
     * @memberof TexteSimple
     */
    'signataireKali'?: SignataireKali;
    /**
     * Indique la publication au recueil Lebon
     * @type {string}
     * @memberof TexteSimple
     */
    'publicationRecueil'?: string;
    /**
     * Solution
     * @type {string}
     * @memberof TexteSimple
     */
    'solution'?: string;
    /**
     * Titre du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'titre'?: string;
    /**
     * Texte HTML des informations restructuration de branche
     * @type {string}
     * @memberof TexteSimple
     */
    'infosRestructurationBrancheHtml'?: string;
    /**
     * Type de texte
     * @type {string}
     * @memberof TexteSimple
     */
    'typeTexte'?: TexteSimpleTypeTexteEnum;
    /**
     * Nature du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'nature'?: string;
    /**
     * Texte HTML des informations complémentaires
     * @type {string}
     * @memberof TexteSimple
     */
    'infosComplementairesHtml'?: string;
    /**
     * Contenu du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'texte'?: string;
    /**
     * Identifiant technique permettant le suivi d\'injection du mode delta
     * @type {string}
     * @memberof TexteSimple
     */
    'idTechInjection'?: string;
    /**
     * Observations d\'une directive européenne
     * @type {string}
     * @memberof TexteSimple
     */
    'observations'?: string;
    /**
     * Texte HTML des résumés de directive européenne
     * @type {string}
     * @memberof TexteSimple
     */
    'resumeHtml'?: string;
    /**
     * référence permettant le suivi d\'injection du mode delta
     * @type {string}
     * @memberof TexteSimple
     */
    'refInjection'?: string;
    /**
     * Numéro du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'num'?: string;
    /**
     * Liste des codes de nomenclature
     * @type {Array<string>}
     * @memberof TexteSimple
     */
    'codesNomenclatures'?: Array<string>;
    /**
     * Numéro de parution
     * @type {string}
     * @memberof TexteSimple
     */
    'numParution'?: string;
    /**
     * Date du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'dateTexte'?: string;
    /**
     * Liste des conteneurs
     * @type {Array<Conteneur>}
     * @memberof TexteSimple
     */
    'conteneurs'?: Array<Conteneur>;
    /**
     * Date de publication
     * @type {string}
     * @memberof TexteSimple
     */
    'datePubli'?: string;
    /**
     * Description de fusion
     * @type {string}
     * @memberof TexteSimple
     */
    'descriptionFusion'?: string;
    /**
     * Texte au format HTML
     * @type {string}
     * @memberof TexteSimple
     */
    'texteHtml'?: string;
    /**
     * 
     * @type {DecisionAttaquee}
     * @memberof TexteSimple
     */
    'decisionAttaquee'?: DecisionAttaquee;
    /**
     * 
     * @type {string}
     * @memberof TexteSimple
     */
    'natureNumero'?: string;
    /**
     * 
     * @type {string}
     * @memberof TexteSimple
     */
    'ancienId'?: string;
    /**
     * Liste des numéros d\'affaire
     * @type {Array<string>}
     * @memberof TexteSimple
     */
    'numeroAffaire'?: Array<string>;
    /**
     * Titre du JO lié
     * @type {string}
     * @memberof TexteSimple
     */
    'titreJo'?: string;
    /**
     * Président
     * @type {string}
     * @memberof TexteSimple
     */
    'president'?: string;
    /**
     * Identifiant du JO
     * @type {string}
     * @memberof TexteSimple
     */
    'idTexteJo'?: string;
    /**
     * Juridiction judiciaire
     * @type {string}
     * @memberof TexteSimple
     */
    'juridictionJudiciaire'?: string;
    /**
     * formation
     * @type {string}
     * @memberof TexteSimple
     */
    'formation'?: string;
    /**
     * Identifiant du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'id'?: string;
    /**
     * Juridiction
     * @type {string}
     * @memberof TexteSimple
     */
    'juridiction'?: string;
    /**
     * Texte HTML des travaux préparatoires
     * @type {string}
     * @memberof TexteSimple
     */
    'travauxPreparatoiresHtml'?: string;
    /**
     * Notice
     * @type {string}
     * @memberof TexteSimple
     */
    'notice'?: string;
    /**
     * Citations jurisprudentielles
     * @type {string}
     * @memberof TexteSimple
     */
    'citationJp'?: string;
    /**
     * INAP
     * @type {boolean}
     * @memberof TexteSimple
     */
    'inap'?: boolean;
    /**
     * Date du texte si la date est valide, vide autrement (elle vaut null si la date du texte est null ou >= 2222-01-01)
     * @type {string}
     * @memberof TexteSimple
     */
    'dateTexteComputed'?: string;
    /**
     * Titre long du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'titreLong'?: string;
    /**
     * Avocats
     * @type {string}
     * @memberof TexteSimple
     */
    'avocats'?: string;
    /**
     * Date de publication si la date est valide, vide autrement (elle vaut null si la date du texte est null ou >= 2222-01-01)
     * @type {string}
     * @memberof TexteSimple
     */
    'datePubliComputed'?: string;
    /**
     * Informations complémentaires
     * @type {string}
     * @memberof TexteSimple
     */
    'infosComplementaires'?: string;
    /**
     * Date de dernière modification
     * @type {string}
     * @memberof TexteSimple
     */
    'dateDerniereModif'?: string;
    /**
     * Signataires
     * @type {string}
     * @memberof TexteSimple
     */
    'signataires'?: string;
    /**
     * Autorité
     * @type {string}
     * @memberof TexteSimple
     */
    'autorite'?: string;
    /**
     * Numéro de séquence
     * @type {string}
     * @memberof TexteSimple
     */
    'numsequence'?: string;
    /**
     * Demandeur du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'demandeur'?: string;
    /**
     * Date du JO
     * @type {string}
     * @memberof TexteSimple
     */
    'dateJo'?: string;
    /**
     * Lien ELI
     * @type {string}
     * @memberof TexteSimple
     */
    'idEli'?: string;
    /**
     * Date de signature de la loi déférée
     * @type {string}
     * @memberof TexteSimple
     */
    'dateLoiDef'?: string;
    /**
     * Type de contrôle
     * @type {string}
     * @memberof TexteSimple
     */
    'typeControleNormes'?: string;
    /**
     * Texte HTML de la description de fusion
     * @type {string}
     * @memberof TexteSimple
     */
    'descriptionFusionHtml'?: string;
    /**
     * Etat juridique
     * @type {string}
     * @memberof TexteSimple
     */
    'etat'?: string;
    /**
     * Liste des mots clés
     * @type {Array<string>}
     * @memberof TexteSimple
     */
    'motsCles'?: Array<string>;
    /**
     * Liste des dossiers législatifs
     * @type {Array<DossierLegislatif>}
     * @memberof TexteSimple
     */
    'dossiersLegislatifs'?: Array<DossierLegislatif>;
    /**
     * Liste des éléments de sommaire
     * @type {Array<TexteSommaire>}
     * @memberof TexteSimple
     */
    'sommaire'?: Array<TexteSommaire>;
    /**
     * Date de versement
     * @type {string}
     * @memberof TexteSimple
     */
    'dateVersement'?: string;
    /**
     * Liste de liens vers d\'autres textes
     * @type {Array<TexteLien>}
     * @memberof TexteSimple
     */
    'liens'?: Array<TexteLien>;
    /**
     * Numéro du JO
     * @type {string}
     * @memberof TexteSimple
     */
    'numJo'?: string;
    /**
     * Siège d\'appel
     * @type {string}
     * @memberof TexteSimple
     */
    'siegeAppel'?: string;
    /**
     * Liste des appellations non officielles
     * @type {Array<string>}
     * @memberof TexteSimple
     */
    'appellations'?: Array<string>;
    /**
     * Origine de la publication
     * @type {string}
     * @memberof TexteSimple
     */
    'originePubli'?: string;
    /**
     * Texte HTML des citations jurisprudentielles
     * @type {string}
     * @memberof TexteSimple
     */
    'citationJpHtml'?: string;
    /**
     * Texte HTML des visas
     * @type {string}
     * @memberof TexteSimple
     */
    'visasHtml'?: string;
    /**
     * Origine du texte
     * @type {string}
     * @memberof TexteSimple
     */
    'origine'?: string;
    /**
     * Date de début
     * @type {string}
     * @memberof TexteSimple
     */
    'dateDebut'?: string;
    /**
     * Lien vers le JO
     * @type {string}
     * @memberof TexteSimple
     */
    'lienJo'?: string;
    /**
     * Année de publication au bulletin
     * @type {string}
     * @memberof TexteSimple
     */
    'annePublicationBulletin'?: string;
    /**
     * Texte HTML des notas
     * @type {string}
     * @memberof TexteSimple
     */
    'notaHtml'?: string;
    /**
     * Rectificatif d\'une directive européenne
     * @type {string}
     * @memberof TexteSimple
     */
    'rectificatif'?: string;
    /**
     * Numéro NOR
     * @type {string}
     * @memberof TexteSimple
     */
    'nor'?: string;
    /**
     * Nature qualifiée
     * @type {string}
     * @memberof TexteSimple
     */
    'natureQualifiee'?: string;
    /**
     * Nature de la juridiction
     * @type {string}
     * @memberof TexteSimple
     */
    'natureJuridiction'?: string;
    /**
     * Type de publication
     * @type {string}
     * @memberof TexteSimple
     */
    'typePublicationBulletin'?: string;
    /**
     * Renvoi
     * @type {string}
     * @memberof TexteSimple
     */
    'renvoi'?: string;
    /**
     * Version
     * @type {string}
     * @memberof TexteSimple
     */
    'version'?: string;
    /**
     * Chemin vers la convention collective
     * @type {string}
     * @memberof TexteSimple
     */
    'urlCC'?: string;
    /**
     * Type de décision
     * @type {string}
     * @memberof TexteSimple
     */
    'typeDecision'?: string;
    /**
     * Rapporteur
     * @type {string}
     * @memberof TexteSimple
     */
    'rapporteur'?: string;
    /**
     * Résumé d\'une directive européenne
     * @type {string}
     * @memberof TexteSimple
     */
    'resume'?: string;
    /**
     * Numéro de pdf
     * @type {string}
     * @memberof TexteSimple
     */
    'pagePdf'?: string;
    /**
     * Numéro de publication au bulletin
     * @type {string}
     * @memberof TexteSimple
     */
    'numeroPublicationBulletin'?: string;
    /**
     * Identifiant du conteneur
     * @type {string}
     * @memberof TexteSimple
     */
    'idConteneur'?: string;
    /**
     * Informations restructuration de branche
     * @type {string}
     * @memberof TexteSimple
     */
    'infosRestructurationBranche'?: string;
}

export const TexteSimpleTypeTexteEnum = {
    Attache: 'TEXTE_ATTACHE',
    Base: 'TEXTE_BASE',
    Salaire: 'TEXTE_SALAIRE',
    Extension: 'TEXTE_EXTENSION'
} as const;

export type TexteSimpleTypeTexteEnum = typeof TexteSimpleTypeTexteEnum[keyof typeof TexteSimpleTypeTexteEnum];

/**
 * Objet représentant un sommaire
 * @export
 * @interface TexteSommaire
 */
export interface TexteSommaire {
    /**
     * Identifiant
     * @type {string}
     * @memberof TexteSommaire
     */
    'id'?: string;
    /**
     * Résumé principal
     * @type {string}
     * @memberof TexteSommaire
     */
    'resumePrincipal'?: string;
    /**
     * Autre résumé
     * @type {string}
     * @memberof TexteSommaire
     */
    'autreResume'?: string;
    /**
     * Abstracts
     * @type {string}
     * @memberof TexteSommaire
     */
    'abstrats'?: string;
}
/**
 * Objet représentant un thème
 * @export
 * @interface Theme
 */
export interface Theme {
    /**
     * Libellé
     * @type {string}
     * @memberof Theme
     */
    'libelle'?: string;
    /**
     * Groupe
     * @type {string}
     * @memberof Theme
     */
    'groupe'?: string;
    /**
     * Code
     * @type {string}
     * @memberof Theme
     */
    'code'?: string;
}
/**
 * Objet représentant l\'arbo d\'un titrage
 * @export
 * @interface Titrage
 */
export interface Titrage {
    /**
     * Identifiant
     * @type {string}
     * @memberof Titrage
     */
    'id'?: string;
}
/**
 * Objet représentant une section d\'un conteneur
 * @export
 * @interface Tms
 */
export interface Tms {
    /**
     * Liste des liens vers les textes de la section courante
     * @type {Array<LienTxt>}
     * @memberof Tms
     */
    'liensTxt'?: Array<LienTxt>;
    /**
     * Niveau de la section
     * @type {number}
     * @memberof Tms
     */
    'niv'?: number;
    /**
     * Titre de la section
     * @type {string}
     * @memberof Tms
     */
    'titre'?: string;
    /**
     * Numéro d\'ordre de la section
     * @type {number}
     * @memberof Tms
     */
    'ordre'?: number;
    /**
     * Liste des sections enfants de la section courante
     * @type {Array<Tms>}
     * @memberof Tms
     */
    'tms'?: Array<Tms>;
}
/**
 * Objet définissant une version d\'un texte
 * @export
 * @interface VersionDTO
 */
export interface VersionDTO {
    /**
     * Détermine s\'il s\'agit de la dernière version.
     * @type {boolean}
     * @memberof VersionDTO
     */
    'isEndVersion'?: boolean;
    /**
     * Date de début de la version
     * @type {string}
     * @memberof VersionDTO
     */
    'dateDebut'?: string;
    /**
     * Map listant les articles ayant apportés des modifications pour cette version. La clé correspond à la date de la version au format AAAA-MM-JJ.
     * @type {{ [key: string]: ArticleModificateurDTO; }}
     * @memberof VersionDTO
     */
    'articlesModificateurs'?: { [key: string]: ArticleModificateurDTO; };
}
/**
 * Résultat d\'une requête pour lister les années sans table annuelle
 * @export
 * @interface YearsWithNoTableResponse
 */
export interface YearsWithNoTableResponse {
    /**
     * Liste des années
     * @type {Array<number>}
     * @memberof YearsWithNoTableResponse
     */
    'lstYearDisabled'?: Array<number>;
}

/**
 * ChronoControllerApi - axios parameter creator
 * @export
 */
export const ChronoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Récupère un extrait (section ou article) d\'une version spécifique d\'un texte à partir des identifiants du texte et de l\'extrait (section ou article)
         * @summary Extrait d\'une version d\'un texte
         * @param {ChronoLegiArticleRequest} request Identifiants techniques du texte et de l\&#39;extrait ciblé (article ou section)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionByTextCidAndElementCidUsingPOST: async (request: ChronoLegiArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('getVersionByTextCidAndElementCidUsingPOST', 'request', request)
            const localVarPath = `/chrono/textCidAndElementCid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère une version spécifique d\'un texte à partir de l\'identifiant du texte
         * @summary Version d\'un texte
         * @param {ChronoLegiTextRequest} request Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionByTextCidUsingPOST: async (request: ChronoLegiTextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('getVersionByTextCidUsingPOST', 'request', request)
            const localVarPath = `/chrono/textCid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Indique si un texte possède des versions chrono à partir de l\'identifiant du texte
         * @summary Vérifie si un texte possède des versions
         * @param {string} textCid Chronical ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasVersionByTextCidUsingGET: async (textCid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textCid' is not null or undefined
            assertParamExists('hasVersionByTextCidUsingGET', 'textCid', textCid)
            const localVarPath = `/chrono/textCid/{textCid}`
                .replace(`{${"textCid"}}`, encodeURIComponent(String(textCid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chrono/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChronoControllerApi - functional programming interface
 * @export
 */
export const ChronoControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChronoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Récupère un extrait (section ou article) d\'une version spécifique d\'un texte à partir des identifiants du texte et de l\'extrait (section ou article)
         * @summary Extrait d\'une version d\'un texte
         * @param {ChronoLegiArticleRequest} request Identifiants techniques du texte et de l\&#39;extrait ciblé (article ou section)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionByTextCidAndElementCidUsingPOST(request: ChronoLegiArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChronolegiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionByTextCidAndElementCidUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère une version spécifique d\'un texte à partir de l\'identifiant du texte
         * @summary Version d\'un texte
         * @param {ChronoLegiTextRequest} request Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionByTextCidUsingPOST(request: ChronoLegiTextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChronolegiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionByTextCidUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Indique si un texte possède des versions chrono à partir de l\'identifiant du texte
         * @summary Vérifie si un texte possède des versions
         * @param {string} textCid Chronical ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasVersionByTextCidUsingGET(textCid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HasChronolegiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasVersionByTextCidUsingGET(textCid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChronoControllerApi - factory interface
 * @export
 */
export const ChronoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChronoControllerApiFp(configuration)
    return {
        /**
         * Récupère un extrait (section ou article) d\'une version spécifique d\'un texte à partir des identifiants du texte et de l\'extrait (section ou article)
         * @summary Extrait d\'une version d\'un texte
         * @param {ChronoLegiArticleRequest} request Identifiants techniques du texte et de l\&#39;extrait ciblé (article ou section)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionByTextCidAndElementCidUsingPOST(request: ChronoLegiArticleRequest, options?: any): AxiosPromise<ChronolegiResponse> {
            return localVarFp.getVersionByTextCidAndElementCidUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère une version spécifique d\'un texte à partir de l\'identifiant du texte
         * @summary Version d\'un texte
         * @param {ChronoLegiTextRequest} request Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionByTextCidUsingPOST(request: ChronoLegiTextRequest, options?: any): AxiosPromise<ChronolegiResponse> {
            return localVarFp.getVersionByTextCidUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Indique si un texte possède des versions chrono à partir de l\'identifiant du texte
         * @summary Vérifie si un texte possède des versions
         * @param {string} textCid Chronical ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasVersionByTextCidUsingGET(textCid: string, options?: any): AxiosPromise<HasChronolegiResponse> {
            return localVarFp.hasVersionByTextCidUsingGET(textCid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET(options?: any): AxiosPromise<string> {
            return localVarFp.pingUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChronoControllerApi - object-oriented interface
 * @export
 * @class ChronoControllerApi
 * @extends {BaseAPI}
 */
export class ChronoControllerApi extends BaseAPI {
    /**
     * Récupère un extrait (section ou article) d\'une version spécifique d\'un texte à partir des identifiants du texte et de l\'extrait (section ou article)
     * @summary Extrait d\'une version d\'un texte
     * @param {ChronoLegiArticleRequest} request Identifiants techniques du texte et de l\&#39;extrait ciblé (article ou section)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChronoControllerApi
     */
    public getVersionByTextCidAndElementCidUsingPOST(request: ChronoLegiArticleRequest, options?: AxiosRequestConfig) {
        return ChronoControllerApiFp(this.configuration).getVersionByTextCidAndElementCidUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère une version spécifique d\'un texte à partir de l\'identifiant du texte
     * @summary Version d\'un texte
     * @param {ChronoLegiTextRequest} request Identifiant technique du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChronoControllerApi
     */
    public getVersionByTextCidUsingPOST(request: ChronoLegiTextRequest, options?: AxiosRequestConfig) {
        return ChronoControllerApiFp(this.configuration).getVersionByTextCidUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Indique si un texte possède des versions chrono à partir de l\'identifiant du texte
     * @summary Vérifie si un texte possède des versions
     * @param {string} textCid Chronical ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChronoControllerApi
     */
    public hasVersionByTextCidUsingGET(textCid: string, options?: AxiosRequestConfig) {
        return ChronoControllerApiFp(this.configuration).hasVersionByTextCidUsingGET(textCid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retourne pong
     * @summary Teste le controller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChronoControllerApi
     */
    public pingUsingGET(options?: AxiosRequestConfig) {
        return ChronoControllerApiFp(this.configuration).pingUsingGET(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConsultControllerApi - axios parameter creator
 * @export
 */
export const ConsultControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Récupère le contenu d\'un accord d\'entreprise à partir de son identifiant
         * @summary Contenu d\'un accord d\'entreprise
         * @param {AccoConsultRequest} [request] Identifiant technique de l\&#39;accord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayAccoUsingPOST: async (request?: AccoConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/acco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'une circulaire à partir de son identifiant
         * @summary Contenu d\'une circualire
         * @param {CirculaireConsultRequest} [request] Identifiant technique de la circualire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayCirculaireUsingPOST: async (request?: CirculaireConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/circulaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds CNIL à partir de son identifiant
         * @summary Contenu texte fonds CNIL
         * @param {CnilConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayCnilUsingPOST: async (request?: CnilConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/cnil`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la table des matières d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
         * @summary Contenu table des matières d\'un CODE (déprécié, utiliser /legi/tableMatieres avec le champ \'nature\'=\'CODE\' à la place)
         * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        displayCodeTableOfContentsUsingPOST: async (codeConsultRequest?: CodeConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/code/tableMatieres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(codeConsultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte type CODE
         * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayCodeUsingPOST: async (codeConsultRequest?: CodeConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(codeConsultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer les liens de concordance d\'un article
         * @summary Liste des liens de concordance d\'un article
         * @param {ConcordanceLinksRequest} [concordanceLinksRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayConcordanceLinksArticleUsingPOST: async (concordanceLinksRequest?: ConcordanceLinksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/concordanceLinksArticle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concordanceLinksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un débat parlementaire à partir de son identifiant
         * @summary Contenu d\'un débat parlementaire
         * @param {DebatParlementaireConsultRequest} [request] Identifiant technique du débat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayDebatUsingPOST: async (request?: DebatParlementaireConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/debat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un dossier legislatif par son identifiant
         * @summary Contenu d\'un dossier législatif
         * @param {DossierLegislatifRequest} [request] Identifiant technique du dossier législatif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayDossierLegislatifUsingPOST: async (request?: DossierLegislatifRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/dossierLegislatif`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste de conteneurs/sommaires JORF
         * @summary Liste de sommaire JORF
         * @param {JorfContConsultRequest} [request] Periode de JORF recherché / id de JORF recherché / numéro de JORF recherché
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJorfContUsingPOST: async (request?: JorfContConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/jorfCont`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de l\'identifiant d\'une de ses sections ou articles
         * @summary Contenu texte fonds JORF
         * @param {JorfConsultRequest} [request] Chronical ID de l\&#39;élément
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJorfPartUsingPOST: async (request?: JorfConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/jorfPart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de son identifiant
         * @summary Contenu texte fonds JORF
         * @param {JorfConsultRequest} [jorfConsultRequest] Chronical ID du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJorfUsingPOST: async (jorfConsultRequest?: JorfConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/jorf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jorfConsultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
         * @summary Contenu texte fonds JURI
         * @param {JuriPlanClassementRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJuriPlanClassementUsingPOST: async (request?: JuriPlanClassementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getJuriPlanClassement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
         * @summary Contenu texte fonds JURI
         * @param {JuriConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJuriUsingPOST: async (request?: JuriConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/juri`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de son article
         * @summary Contenu des conventions collectives depuis un article
         * @param {KaliTextConsultArticleRequest} [request] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliArticleUsingPOST: async (request?: KaliTextConsultArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/kaliArticle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son idcc
         * @summary Contenu des conteneurs des conventions collectives
         * @param {KaliContConsultIdccRequest} [request] Identifiant fonctionnel du texte : l\&#39;idcc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliContByIdccUsingPOST: async (request?: KaliContConsultIdccRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/kaliContIdcc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son identifiant
         * @summary Contenu des conteneurs des conventions collectives
         * @param {KaliContConsultRequest} [request] Identifiant technique du conteneur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliContUsingPOST: async (request?: KaliContConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/kaliCont`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de sa section
         * @summary Contenu des conventions collectives depuis une section
         * @param {KaliTextConsultSectionRequest} [request] Identifiant technique de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliSectionUsingPOST: async (request?: KaliTextConsultSectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/kaliSection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de son identifiant
         * @summary Contenu des conventions collectives
         * @param {KaliTextConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliTextUsingPOST: async (request?: KaliTextConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/kaliText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte de type LODA à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte type LODA
         * @param {LawDecreeConsultRequest} [lawDecreeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayLawDecreeUsingPOST: async (lawDecreeConsultRequest?: LawDecreeConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/lawDecree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lawDecreeConsultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds LEGI à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte fonds LEGI
         * @param {LegiConsultRequest} legiConsultRequest Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayLegiPartUsingPOST: async (legiConsultRequest: LegiConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'legiConsultRequest' is not null or undefined
            assertParamExists('displayLegiPartUsingPOST', 'legiConsultRequest', legiConsultRequest)
            const localVarPath = `/consult/legiPart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(legiConsultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer les liens relatifs d\'un article donné
         * @summary Liste des liens relatifs d\'un article
         * @param {RelatedLinksArticleRequest} [relatedLinksArticleRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayRelatedLinksArticleUsingPOST: async (relatedLinksArticleRequest?: RelatedLinksArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/relatedLinksArticle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relatedLinksArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer les liens des articles ayant eu le même numéro que l\'article en cours dans des versions précédentes du texte
         * @summary Liste des articles ayant eu le même numéro
         * @param {SameNumArticleRequest} [sameNumArticleRequest] Identifiant commun du texte / identifiant commun de l\&#39;article / numéro de l\&#39;article / date de référence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displaySameNumArticleUsingPOST: async (sameNumArticleRequest?: SameNumArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/sameNumArticle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sameNumArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la table des matières d\'un texte de type CODE ou LODA à partir de son identifiant, sa date de vigueur. Possibilité de rechercher uniquement les codes en positionnant \'nature\' sur \'CODE\'
         * @summary Contenu table des matières d\'un texte LODA ou CODE
         * @param {LegiSommaireConsultRequest} [sommaireRequest] Filtre de recherche d\&#39;un sommaire contenant un id/cid, une date et la nature texte recherché
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayTextTableOfContentsUsingPOST: async (sommaireRequest?: LegiSommaireConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/legi/tableMatieres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sommaireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des articles par leur identifiant commun
         * @summary Contenu des versions d\'un article
         * @param {ArticleCidRequest} [request] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleByCidUsingPOST: async (request?: ArticleCidRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getArticleByCid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un article par son identifiant
         * @summary Contenu d\'un article
         * @param {ArticleRequest} [articleRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleUsingPOST: async (articleRequest?: ArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getArticle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(articleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un Article en fonction de son  ID et Numéro article
         * @summary Contenu d\'un Article
         * @param {ArticleConsultWithIdAndNum} [request] Id et Num
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleWithIdAndNumUsingPOST: async (request?: ArticleConsultWithIdAndNum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getArticleWithIdAndNum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un article par son identifiant Eli ou Alias
         * @summary Contenu d\'un article
         * @param {ArticleIdEliOrAliasRequest} [request] Identifiant Eli ou alias de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleWithIdEliOrAliasUsingPOST: async (request?: ArticleIdEliOrAliasRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getArticleWithIdEliOrAlias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Métadonnées d\'un PDF lié à un texte unitaire BOCC
         * @param {BoccConsultRequest} [request] id du texte BOCC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoccTextPdfMetadataUsingPOST: async (request?: BoccConsultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getBoccTextPdfMetadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un texte du fond CNIL en fonction de son Ancien ID
         * @summary Contenu d\'un texte CNIL
         * @param {CnilConsultWithAncienId} [request] AncienId du texte cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCnilWithAncienIdUsingPOST: async (request?: CnilConsultWithAncienId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getCnilWithAncienId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un Code en fonction de son Ancien ID
         * @summary Contenu d\'un Code
         * @param {CodeConsultWithAncienId} [request] AncienId du code cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeWithAncienIdUsingPOST: async (request?: CodeConsultWithAncienId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getCodeWithAncienId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de son idEli ou idEliAlias
         * @summary Contenu des textes du JO.
         * @param {JorfConsultWithIdEliAliasRequest} [jorfConsultWithIdEliAliasRequest] idEli ou idEliAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoCidWithEliOrAliasUsingPOST: async (jorfConsultWithIdEliAliasRequest?: JorfConsultWithIdEliAliasRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/eliAndAliasRedirectionTexte`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jorfConsultWithIdEliAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un JO en fonction de son NOR
         * @summary Contenu d\'un JO
         * @param {JorfConsultWithNorRequest} [request] NOR du JO cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoWithNorUsingPOST: async (request?: JorfConsultWithNorRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getJoWithNor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un texte du fond juri en fonction de son Ancien ID
         * @summary Contenu d\'un texte juri
         * @param {JuriConsultWithAncienId} [request] AncienId du texte cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJuriWithAncienIdUsingPOST: async (request?: JuriConsultWithAncienId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getJuriWithAncienId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les derniers journaux officiels
         * @summary Derniers journaux officels
         * @param {LastNElementRequest} [request] Nombre de JOs à remonter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastNJoUsingPOST: async (request?: LastNElementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/lastNJo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des section par leur identifiant commun
         * @summary Contenu d\'une section
         * @param {SectionCidRequest} [request] Identifiant technique de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionByCidUsingPOST: async (request?: SectionCidRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getSectionByCid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer l\'ensemble des tables annuelles pour une période donnée
         * @summary Liste des tables annuelles
         * @param {TableRequest} [request] Période en année de la recherche des tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTablesUsingPOST: async (request?: TableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/getTables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consult/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsultControllerApi - functional programming interface
 * @export
 */
export const ConsultControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsultControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Récupère le contenu d\'un accord d\'entreprise à partir de son identifiant
         * @summary Contenu d\'un accord d\'entreprise
         * @param {AccoConsultRequest} [request] Identifiant technique de l\&#39;accord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayAccoUsingPOST(request?: AccoConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultAccoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayAccoUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'une circulaire à partir de son identifiant
         * @summary Contenu d\'une circualire
         * @param {CirculaireConsultRequest} [request] Identifiant technique de la circualire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayCirculaireUsingPOST(request?: CirculaireConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultCirculaireResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayCirculaireUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds CNIL à partir de son identifiant
         * @summary Contenu texte fonds CNIL
         * @param {CnilConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayCnilUsingPOST(request?: CnilConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultCnilTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayCnilUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère la table des matières d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
         * @summary Contenu table des matières d\'un CODE (déprécié, utiliser /legi/tableMatieres avec le champ \'nature\'=\'CODE\' à la place)
         * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async displayCodeTableOfContentsUsingPOST(codeConsultRequest?: CodeConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayCodeTableOfContentsUsingPOST(codeConsultRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte type CODE
         * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayCodeUsingPOST(codeConsultRequest?: CodeConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayCodeUsingPOST(codeConsultRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer les liens de concordance d\'un article
         * @summary Liste des liens de concordance d\'un article
         * @param {ConcordanceLinksRequest} [concordanceLinksRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayConcordanceLinksArticleUsingPOST(concordanceLinksRequest?: ConcordanceLinksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsRevisionArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayConcordanceLinksArticleUsingPOST(concordanceLinksRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un débat parlementaire à partir de son identifiant
         * @summary Contenu d\'un débat parlementaire
         * @param {DebatParlementaireConsultRequest} [request] Identifiant technique du débat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayDebatUsingPOST(request?: DebatParlementaireConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultDebatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayDebatUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un dossier legislatif par son identifiant
         * @summary Contenu d\'un dossier législatif
         * @param {DossierLegislatifRequest} [request] Identifiant technique du dossier législatif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayDossierLegislatifUsingPOST(request?: DossierLegislatifRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultDossierLegislatifResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayDossierLegislatifUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère la liste de conteneurs/sommaires JORF
         * @summary Liste de sommaire JORF
         * @param {JorfContConsultRequest} [request] Periode de JORF recherché / id de JORF recherché / numéro de JORF recherché
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayJorfContUsingPOST(request?: JorfContConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayJorfContUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de l\'identifiant d\'une de ses sections ou articles
         * @summary Contenu texte fonds JORF
         * @param {JorfConsultRequest} [request] Chronical ID de l\&#39;élément
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayJorfPartUsingPOST(request?: JorfConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultJorfResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayJorfPartUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de son identifiant
         * @summary Contenu texte fonds JORF
         * @param {JorfConsultRequest} [jorfConsultRequest] Chronical ID du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayJorfUsingPOST(jorfConsultRequest?: JorfConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultJorfResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayJorfUsingPOST(jorfConsultRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
         * @summary Contenu texte fonds JURI
         * @param {JuriPlanClassementRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayJuriPlanClassementUsingPOST(request?: JuriPlanClassementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListPlanClassementJuriResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayJuriPlanClassementUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
         * @summary Contenu texte fonds JURI
         * @param {JuriConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayJuriUsingPOST(request?: JuriConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultJuriTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayJuriUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de son article
         * @summary Contenu des conventions collectives depuis un article
         * @param {KaliTextConsultArticleRequest} [request] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayKaliArticleUsingPOST(request?: KaliTextConsultArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultKaliTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayKaliArticleUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son idcc
         * @summary Contenu des conteneurs des conventions collectives
         * @param {KaliContConsultIdccRequest} [request] Identifiant fonctionnel du texte : l\&#39;idcc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayKaliContByIdccUsingPOST(request?: KaliContConsultIdccRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultKaliContResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayKaliContByIdccUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son identifiant
         * @summary Contenu des conteneurs des conventions collectives
         * @param {KaliContConsultRequest} [request] Identifiant technique du conteneur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayKaliContUsingPOST(request?: KaliContConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultKaliContResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayKaliContUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de sa section
         * @summary Contenu des conventions collectives depuis une section
         * @param {KaliTextConsultSectionRequest} [request] Identifiant technique de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayKaliSectionUsingPOST(request?: KaliTextConsultSectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultKaliTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayKaliSectionUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de son identifiant
         * @summary Contenu des conventions collectives
         * @param {KaliTextConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayKaliTextUsingPOST(request?: KaliTextConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultKaliTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayKaliTextUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte de type LODA à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte type LODA
         * @param {LawDecreeConsultRequest} [lawDecreeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayLawDecreeUsingPOST(lawDecreeConsultRequest?: LawDecreeConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayLawDecreeUsingPOST(lawDecreeConsultRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds LEGI à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte fonds LEGI
         * @param {LegiConsultRequest} legiConsultRequest Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayLegiPartUsingPOST(legiConsultRequest: LegiConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayLegiPartUsingPOST(legiConsultRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer les liens relatifs d\'un article donné
         * @summary Liste des liens relatifs d\'un article
         * @param {RelatedLinksArticleRequest} [relatedLinksArticleRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayRelatedLinksArticleUsingPOST(relatedLinksArticleRequest?: RelatedLinksArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedLinksArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayRelatedLinksArticleUsingPOST(relatedLinksArticleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer les liens des articles ayant eu le même numéro que l\'article en cours dans des versions précédentes du texte
         * @summary Liste des articles ayant eu le même numéro
         * @param {SameNumArticleRequest} [sameNumArticleRequest] Identifiant commun du texte / identifiant commun de l\&#39;article / numéro de l\&#39;article / date de référence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displaySameNumArticleUsingPOST(sameNumArticleRequest?: SameNumArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionsRevisionArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displaySameNumArticleUsingPOST(sameNumArticleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère la table des matières d\'un texte de type CODE ou LODA à partir de son identifiant, sa date de vigueur. Possibilité de rechercher uniquement les codes en positionnant \'nature\' sur \'CODE\'
         * @summary Contenu table des matières d\'un texte LODA ou CODE
         * @param {LegiSommaireConsultRequest} [sommaireRequest] Filtre de recherche d\&#39;un sommaire contenant un id/cid, une date et la nature texte recherché
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayTextTableOfContentsUsingPOST(sommaireRequest?: LegiSommaireConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayTextTableOfContentsUsingPOST(sommaireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère la liste des articles par leur identifiant commun
         * @summary Contenu des versions d\'un article
         * @param {ArticleCidRequest} [request] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleByCidUsingPOST(request?: ArticleCidRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticleByCidUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère un article par son identifiant
         * @summary Contenu d\'un article
         * @param {ArticleRequest} [articleRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleUsingPOST(articleRequest?: ArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticleUsingPOST(articleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère un Article en fonction de son  ID et Numéro article
         * @summary Contenu d\'un Article
         * @param {ArticleConsultWithIdAndNum} [request] Id et Num
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleWithIdAndNumUsingPOST(request?: ArticleConsultWithIdAndNum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticleWithIdAndNumUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère un article par son identifiant Eli ou Alias
         * @summary Contenu d\'un article
         * @param {ArticleIdEliOrAliasRequest} [request] Identifiant Eli ou alias de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleWithIdEliOrAliasUsingPOST(request?: ArticleIdEliOrAliasRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticleWithIdEliOrAliasUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Métadonnées d\'un PDF lié à un texte unitaire BOCC
         * @param {BoccConsultRequest} [request] id du texte BOCC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoccTextPdfMetadataUsingPOST(request?: BoccConsultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultBoccResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBoccTextPdfMetadataUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère un texte du fond CNIL en fonction de son Ancien ID
         * @summary Contenu d\'un texte CNIL
         * @param {CnilConsultWithAncienId} [request] AncienId du texte cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCnilWithAncienIdUsingPOST(request?: CnilConsultWithAncienId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultCnilTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCnilWithAncienIdUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère un Code en fonction de son Ancien ID
         * @summary Contenu d\'un Code
         * @param {CodeConsultWithAncienId} [request] AncienId du code cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeWithAncienIdUsingPOST(request?: CodeConsultWithAncienId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeWithAncienIdUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de son idEli ou idEliAlias
         * @summary Contenu des textes du JO.
         * @param {JorfConsultWithIdEliAliasRequest} [jorfConsultWithIdEliAliasRequest] idEli ou idEliAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJoCidWithEliOrAliasUsingPOST(jorfConsultWithIdEliAliasRequest?: JorfConsultWithIdEliAliasRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultJorfResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJoCidWithEliOrAliasUsingPOST(jorfConsultWithIdEliAliasRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère un JO en fonction de son NOR
         * @summary Contenu d\'un JO
         * @param {JorfConsultWithNorRequest} [request] NOR du JO cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJoWithNorUsingPOST(request?: JorfConsultWithNorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultJorfResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJoWithNorUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère un texte du fond juri en fonction de son Ancien ID
         * @summary Contenu d\'un texte juri
         * @param {JuriConsultWithAncienId} [request] AncienId du texte cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJuriWithAncienIdUsingPOST(request?: JuriConsultWithAncienId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsultJuriTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJuriWithAncienIdUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère les derniers journaux officiels
         * @summary Derniers journaux officels
         * @param {LastNElementRequest} [request] Nombre de JOs à remonter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastNJoUsingPOST(request?: LastNElementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJorfContResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastNJoUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère la liste des section par leur identifiant commun
         * @summary Contenu d\'une section
         * @param {SectionCidRequest} [request] Identifiant technique de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionByCidUsingPOST(request?: SectionCidRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListSectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionByCidUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer l\'ensemble des tables annuelles pour une période donnée
         * @summary Liste des tables annuelles
         * @param {TableRequest} [request] Période en année de la recherche des tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTablesUsingPOST(request?: TableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTablesUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingUsingGET1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingUsingGET1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConsultControllerApi - factory interface
 * @export
 */
export const ConsultControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsultControllerApiFp(configuration)
    return {
        /**
         * Récupère le contenu d\'un accord d\'entreprise à partir de son identifiant
         * @summary Contenu d\'un accord d\'entreprise
         * @param {AccoConsultRequest} [request] Identifiant technique de l\&#39;accord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayAccoUsingPOST(request?: AccoConsultRequest, options?: any): AxiosPromise<ConsultAccoResponse> {
            return localVarFp.displayAccoUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'une circulaire à partir de son identifiant
         * @summary Contenu d\'une circualire
         * @param {CirculaireConsultRequest} [request] Identifiant technique de la circualire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayCirculaireUsingPOST(request?: CirculaireConsultRequest, options?: any): AxiosPromise<ConsultCirculaireResponse> {
            return localVarFp.displayCirculaireUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds CNIL à partir de son identifiant
         * @summary Contenu texte fonds CNIL
         * @param {CnilConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayCnilUsingPOST(request?: CnilConsultRequest, options?: any): AxiosPromise<ConsultCnilTextResponse> {
            return localVarFp.displayCnilUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la table des matières d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
         * @summary Contenu table des matières d\'un CODE (déprécié, utiliser /legi/tableMatieres avec le champ \'nature\'=\'CODE\' à la place)
         * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        displayCodeTableOfContentsUsingPOST(codeConsultRequest?: CodeConsultRequest, options?: any): AxiosPromise<ConsultTextResponse> {
            return localVarFp.displayCodeTableOfContentsUsingPOST(codeConsultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte type CODE
         * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayCodeUsingPOST(codeConsultRequest?: CodeConsultRequest, options?: any): AxiosPromise<ConsultTextResponse> {
            return localVarFp.displayCodeUsingPOST(codeConsultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer les liens de concordance d\'un article
         * @summary Liste des liens de concordance d\'un article
         * @param {ConcordanceLinksRequest} [concordanceLinksRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayConcordanceLinksArticleUsingPOST(concordanceLinksRequest?: ConcordanceLinksRequest, options?: any): AxiosPromise<SectionsRevisionArticleResponse> {
            return localVarFp.displayConcordanceLinksArticleUsingPOST(concordanceLinksRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un débat parlementaire à partir de son identifiant
         * @summary Contenu d\'un débat parlementaire
         * @param {DebatParlementaireConsultRequest} [request] Identifiant technique du débat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayDebatUsingPOST(request?: DebatParlementaireConsultRequest, options?: any): AxiosPromise<ConsultDebatResponse> {
            return localVarFp.displayDebatUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un dossier legislatif par son identifiant
         * @summary Contenu d\'un dossier législatif
         * @param {DossierLegislatifRequest} [request] Identifiant technique du dossier législatif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayDossierLegislatifUsingPOST(request?: DossierLegislatifRequest, options?: any): AxiosPromise<ConsultDossierLegislatifResponse> {
            return localVarFp.displayDossierLegislatifUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste de conteneurs/sommaires JORF
         * @summary Liste de sommaire JORF
         * @param {JorfContConsultRequest} [request] Periode de JORF recherché / id de JORF recherché / numéro de JORF recherché
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJorfContUsingPOST(request?: JorfContConsultRequest, options?: any): AxiosPromise<GetJosResponse> {
            return localVarFp.displayJorfContUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de l\'identifiant d\'une de ses sections ou articles
         * @summary Contenu texte fonds JORF
         * @param {JorfConsultRequest} [request] Chronical ID de l\&#39;élément
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJorfPartUsingPOST(request?: JorfConsultRequest, options?: any): AxiosPromise<ConsultJorfResponse> {
            return localVarFp.displayJorfPartUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de son identifiant
         * @summary Contenu texte fonds JORF
         * @param {JorfConsultRequest} [jorfConsultRequest] Chronical ID du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJorfUsingPOST(jorfConsultRequest?: JorfConsultRequest, options?: any): AxiosPromise<ConsultJorfResponse> {
            return localVarFp.displayJorfUsingPOST(jorfConsultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
         * @summary Contenu texte fonds JURI
         * @param {JuriPlanClassementRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJuriPlanClassementUsingPOST(request?: JuriPlanClassementRequest, options?: any): AxiosPromise<GetListPlanClassementJuriResponse> {
            return localVarFp.displayJuriPlanClassementUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
         * @summary Contenu texte fonds JURI
         * @param {JuriConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayJuriUsingPOST(request?: JuriConsultRequest, options?: any): AxiosPromise<ConsultJuriTextResponse> {
            return localVarFp.displayJuriUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de son article
         * @summary Contenu des conventions collectives depuis un article
         * @param {KaliTextConsultArticleRequest} [request] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliArticleUsingPOST(request?: KaliTextConsultArticleRequest, options?: any): AxiosPromise<ConsultKaliTextResponse> {
            return localVarFp.displayKaliArticleUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son idcc
         * @summary Contenu des conteneurs des conventions collectives
         * @param {KaliContConsultIdccRequest} [request] Identifiant fonctionnel du texte : l\&#39;idcc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliContByIdccUsingPOST(request?: KaliContConsultIdccRequest, options?: any): AxiosPromise<ConsultKaliContResponse> {
            return localVarFp.displayKaliContByIdccUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son identifiant
         * @summary Contenu des conteneurs des conventions collectives
         * @param {KaliContConsultRequest} [request] Identifiant technique du conteneur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliContUsingPOST(request?: KaliContConsultRequest, options?: any): AxiosPromise<ConsultKaliContResponse> {
            return localVarFp.displayKaliContUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de sa section
         * @summary Contenu des conventions collectives depuis une section
         * @param {KaliTextConsultSectionRequest} [request] Identifiant technique de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliSectionUsingPOST(request?: KaliTextConsultSectionRequest, options?: any): AxiosPromise<ConsultKaliTextResponse> {
            return localVarFp.displayKaliSectionUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de son identifiant
         * @summary Contenu des conventions collectives
         * @param {KaliTextConsultRequest} [request] Identifiant technique du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayKaliTextUsingPOST(request?: KaliTextConsultRequest, options?: any): AxiosPromise<ConsultKaliTextResponse> {
            return localVarFp.displayKaliTextUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte de type LODA à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte type LODA
         * @param {LawDecreeConsultRequest} [lawDecreeConsultRequest] Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayLawDecreeUsingPOST(lawDecreeConsultRequest?: LawDecreeConsultRequest, options?: any): AxiosPromise<ConsultTextResponse> {
            return localVarFp.displayLawDecreeUsingPOST(lawDecreeConsultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds LEGI à partir de son identifiant et de sa date de vigueur
         * @summary Contenu texte fonds LEGI
         * @param {LegiConsultRequest} legiConsultRequest Identifiant technique et date de version du texte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayLegiPartUsingPOST(legiConsultRequest: LegiConsultRequest, options?: any): AxiosPromise<ConsultTextResponse> {
            return localVarFp.displayLegiPartUsingPOST(legiConsultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer les liens relatifs d\'un article donné
         * @summary Liste des liens relatifs d\'un article
         * @param {RelatedLinksArticleRequest} [relatedLinksArticleRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayRelatedLinksArticleUsingPOST(relatedLinksArticleRequest?: RelatedLinksArticleRequest, options?: any): AxiosPromise<RelatedLinksArticleResponse> {
            return localVarFp.displayRelatedLinksArticleUsingPOST(relatedLinksArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer les liens des articles ayant eu le même numéro que l\'article en cours dans des versions précédentes du texte
         * @summary Liste des articles ayant eu le même numéro
         * @param {SameNumArticleRequest} [sameNumArticleRequest] Identifiant commun du texte / identifiant commun de l\&#39;article / numéro de l\&#39;article / date de référence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displaySameNumArticleUsingPOST(sameNumArticleRequest?: SameNumArticleRequest, options?: any): AxiosPromise<SectionsRevisionArticleResponse> {
            return localVarFp.displaySameNumArticleUsingPOST(sameNumArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la table des matières d\'un texte de type CODE ou LODA à partir de son identifiant, sa date de vigueur. Possibilité de rechercher uniquement les codes en positionnant \'nature\' sur \'CODE\'
         * @summary Contenu table des matières d\'un texte LODA ou CODE
         * @param {LegiSommaireConsultRequest} [sommaireRequest] Filtre de recherche d\&#39;un sommaire contenant un id/cid, une date et la nature texte recherché
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayTextTableOfContentsUsingPOST(sommaireRequest?: LegiSommaireConsultRequest, options?: any): AxiosPromise<ConsultTextResponse> {
            return localVarFp.displayTextTableOfContentsUsingPOST(sommaireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des articles par leur identifiant commun
         * @summary Contenu des versions d\'un article
         * @param {ArticleCidRequest} [request] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleByCidUsingPOST(request?: ArticleCidRequest, options?: any): AxiosPromise<GetListArticleResponse> {
            return localVarFp.getArticleByCidUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un article par son identifiant
         * @summary Contenu d\'un article
         * @param {ArticleRequest} [articleRequest] Identifiant technique de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleUsingPOST(articleRequest?: ArticleRequest, options?: any): AxiosPromise<GetArticleResponse> {
            return localVarFp.getArticleUsingPOST(articleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un Article en fonction de son  ID et Numéro article
         * @summary Contenu d\'un Article
         * @param {ArticleConsultWithIdAndNum} [request] Id et Num
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleWithIdAndNumUsingPOST(request?: ArticleConsultWithIdAndNum, options?: any): AxiosPromise<GetArticleResponse> {
            return localVarFp.getArticleWithIdAndNumUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un article par son identifiant Eli ou Alias
         * @summary Contenu d\'un article
         * @param {ArticleIdEliOrAliasRequest} [request] Identifiant Eli ou alias de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleWithIdEliOrAliasUsingPOST(request?: ArticleIdEliOrAliasRequest, options?: any): AxiosPromise<GetArticleResponse> {
            return localVarFp.getArticleWithIdEliOrAliasUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Métadonnées d\'un PDF lié à un texte unitaire BOCC
         * @param {BoccConsultRequest} [request] id du texte BOCC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoccTextPdfMetadataUsingPOST(request?: BoccConsultRequest, options?: any): AxiosPromise<ConsultBoccResponse> {
            return localVarFp.getBoccTextPdfMetadataUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un texte du fond CNIL en fonction de son Ancien ID
         * @summary Contenu d\'un texte CNIL
         * @param {CnilConsultWithAncienId} [request] AncienId du texte cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCnilWithAncienIdUsingPOST(request?: CnilConsultWithAncienId, options?: any): AxiosPromise<ConsultCnilTextResponse> {
            return localVarFp.getCnilWithAncienIdUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un Code en fonction de son Ancien ID
         * @summary Contenu d\'un Code
         * @param {CodeConsultWithAncienId} [request] AncienId du code cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeWithAncienIdUsingPOST(request?: CodeConsultWithAncienId, options?: any): AxiosPromise<ConsultTextResponse> {
            return localVarFp.getCodeWithAncienIdUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le contenu d\'un texte du fonds JORF à partir de son idEli ou idEliAlias
         * @summary Contenu des textes du JO.
         * @param {JorfConsultWithIdEliAliasRequest} [jorfConsultWithIdEliAliasRequest] idEli ou idEliAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoCidWithEliOrAliasUsingPOST(jorfConsultWithIdEliAliasRequest?: JorfConsultWithIdEliAliasRequest, options?: any): AxiosPromise<ConsultJorfResponse> {
            return localVarFp.getJoCidWithEliOrAliasUsingPOST(jorfConsultWithIdEliAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un JO en fonction de son NOR
         * @summary Contenu d\'un JO
         * @param {JorfConsultWithNorRequest} [request] NOR du JO cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoWithNorUsingPOST(request?: JorfConsultWithNorRequest, options?: any): AxiosPromise<ConsultJorfResponse> {
            return localVarFp.getJoWithNorUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un texte du fond juri en fonction de son Ancien ID
         * @summary Contenu d\'un texte juri
         * @param {JuriConsultWithAncienId} [request] AncienId du texte cible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJuriWithAncienIdUsingPOST(request?: JuriConsultWithAncienId, options?: any): AxiosPromise<ConsultJuriTextResponse> {
            return localVarFp.getJuriWithAncienIdUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les derniers journaux officiels
         * @summary Derniers journaux officels
         * @param {LastNElementRequest} [request] Nombre de JOs à remonter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastNJoUsingPOST(request?: LastNElementRequest, options?: any): AxiosPromise<GetJorfContResponse> {
            return localVarFp.getLastNJoUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des section par leur identifiant commun
         * @summary Contenu d\'une section
         * @param {SectionCidRequest} [request] Identifiant technique de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionByCidUsingPOST(request?: SectionCidRequest, options?: any): AxiosPromise<GetListSectionResponse> {
            return localVarFp.getSectionByCidUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer l\'ensemble des tables annuelles pour une période donnée
         * @summary Liste des tables annuelles
         * @param {TableRequest} [request] Période en année de la recherche des tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTablesUsingPOST(request?: TableRequest, options?: any): AxiosPromise<GetTableResponse> {
            return localVarFp.getTablesUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET1(options?: any): AxiosPromise<string> {
            return localVarFp.pingUsingGET1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConsultControllerApi - object-oriented interface
 * @export
 * @class ConsultControllerApi
 * @extends {BaseAPI}
 */
export class ConsultControllerApi extends BaseAPI {
    /**
     * Récupère le contenu d\'un accord d\'entreprise à partir de son identifiant
     * @summary Contenu d\'un accord d\'entreprise
     * @param {AccoConsultRequest} [request] Identifiant technique de l\&#39;accord
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayAccoUsingPOST(request?: AccoConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayAccoUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'une circulaire à partir de son identifiant
     * @summary Contenu d\'une circualire
     * @param {CirculaireConsultRequest} [request] Identifiant technique de la circualire
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayCirculaireUsingPOST(request?: CirculaireConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayCirculaireUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds CNIL à partir de son identifiant
     * @summary Contenu texte fonds CNIL
     * @param {CnilConsultRequest} [request] Identifiant technique du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayCnilUsingPOST(request?: CnilConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayCnilUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la table des matières d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
     * @summary Contenu table des matières d\'un CODE (déprécié, utiliser /legi/tableMatieres avec le champ \'nature\'=\'CODE\' à la place)
     * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayCodeTableOfContentsUsingPOST(codeConsultRequest?: CodeConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayCodeTableOfContentsUsingPOST(codeConsultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte de type CODE à partir de son identifiant et de sa date de vigueur
     * @summary Contenu texte type CODE
     * @param {CodeConsultRequest} [codeConsultRequest] Identifiant technique et date de version du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayCodeUsingPOST(codeConsultRequest?: CodeConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayCodeUsingPOST(codeConsultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer les liens de concordance d\'un article
     * @summary Liste des liens de concordance d\'un article
     * @param {ConcordanceLinksRequest} [concordanceLinksRequest] Identifiant technique de l\&#39;article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayConcordanceLinksArticleUsingPOST(concordanceLinksRequest?: ConcordanceLinksRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayConcordanceLinksArticleUsingPOST(concordanceLinksRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un débat parlementaire à partir de son identifiant
     * @summary Contenu d\'un débat parlementaire
     * @param {DebatParlementaireConsultRequest} [request] Identifiant technique du débat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayDebatUsingPOST(request?: DebatParlementaireConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayDebatUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un dossier legislatif par son identifiant
     * @summary Contenu d\'un dossier législatif
     * @param {DossierLegislatifRequest} [request] Identifiant technique du dossier législatif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayDossierLegislatifUsingPOST(request?: DossierLegislatifRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayDossierLegislatifUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste de conteneurs/sommaires JORF
     * @summary Liste de sommaire JORF
     * @param {JorfContConsultRequest} [request] Periode de JORF recherché / id de JORF recherché / numéro de JORF recherché
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayJorfContUsingPOST(request?: JorfContConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayJorfContUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds JORF à partir de l\'identifiant d\'une de ses sections ou articles
     * @summary Contenu texte fonds JORF
     * @param {JorfConsultRequest} [request] Chronical ID de l\&#39;élément
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayJorfPartUsingPOST(request?: JorfConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayJorfPartUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds JORF à partir de son identifiant
     * @summary Contenu texte fonds JORF
     * @param {JorfConsultRequest} [jorfConsultRequest] Chronical ID du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayJorfUsingPOST(jorfConsultRequest?: JorfConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayJorfUsingPOST(jorfConsultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
     * @summary Contenu texte fonds JURI
     * @param {JuriPlanClassementRequest} [request] Identifiant technique du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayJuriPlanClassementUsingPOST(request?: JuriPlanClassementRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayJuriPlanClassementUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds JURI à partir de son identifiant
     * @summary Contenu texte fonds JURI
     * @param {JuriConsultRequest} [request] Identifiant technique du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayJuriUsingPOST(request?: JuriConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayJuriUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de son article
     * @summary Contenu des conventions collectives depuis un article
     * @param {KaliTextConsultArticleRequest} [request] Identifiant technique de l\&#39;article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayKaliArticleUsingPOST(request?: KaliTextConsultArticleRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayKaliArticleUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son idcc
     * @summary Contenu des conteneurs des conventions collectives
     * @param {KaliContConsultIdccRequest} [request] Identifiant fonctionnel du texte : l\&#39;idcc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayKaliContByIdccUsingPOST(request?: KaliContConsultIdccRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayKaliContByIdccUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un conteneur du fonds des conventions collectives (KALI) à partir de son identifiant
     * @summary Contenu des conteneurs des conventions collectives
     * @param {KaliContConsultRequest} [request] Identifiant technique du conteneur
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayKaliContUsingPOST(request?: KaliContConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayKaliContUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de l\'identifiant de sa section
     * @summary Contenu des conventions collectives depuis une section
     * @param {KaliTextConsultSectionRequest} [request] Identifiant technique de la section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayKaliSectionUsingPOST(request?: KaliTextConsultSectionRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayKaliSectionUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds des conventions collectives (KALI) à partir de son identifiant
     * @summary Contenu des conventions collectives
     * @param {KaliTextConsultRequest} [request] Identifiant technique du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayKaliTextUsingPOST(request?: KaliTextConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayKaliTextUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte de type LODA à partir de son identifiant et de sa date de vigueur
     * @summary Contenu texte type LODA
     * @param {LawDecreeConsultRequest} [lawDecreeConsultRequest] Identifiant technique et date de version du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayLawDecreeUsingPOST(lawDecreeConsultRequest?: LawDecreeConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayLawDecreeUsingPOST(lawDecreeConsultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds LEGI à partir de son identifiant et de sa date de vigueur
     * @summary Contenu texte fonds LEGI
     * @param {LegiConsultRequest} legiConsultRequest Identifiant technique et date de version du texte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayLegiPartUsingPOST(legiConsultRequest: LegiConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayLegiPartUsingPOST(legiConsultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer les liens relatifs d\'un article donné
     * @summary Liste des liens relatifs d\'un article
     * @param {RelatedLinksArticleRequest} [relatedLinksArticleRequest] Identifiant technique de l\&#39;article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayRelatedLinksArticleUsingPOST(relatedLinksArticleRequest?: RelatedLinksArticleRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayRelatedLinksArticleUsingPOST(relatedLinksArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer les liens des articles ayant eu le même numéro que l\'article en cours dans des versions précédentes du texte
     * @summary Liste des articles ayant eu le même numéro
     * @param {SameNumArticleRequest} [sameNumArticleRequest] Identifiant commun du texte / identifiant commun de l\&#39;article / numéro de l\&#39;article / date de référence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displaySameNumArticleUsingPOST(sameNumArticleRequest?: SameNumArticleRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displaySameNumArticleUsingPOST(sameNumArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la table des matières d\'un texte de type CODE ou LODA à partir de son identifiant, sa date de vigueur. Possibilité de rechercher uniquement les codes en positionnant \'nature\' sur \'CODE\'
     * @summary Contenu table des matières d\'un texte LODA ou CODE
     * @param {LegiSommaireConsultRequest} [sommaireRequest] Filtre de recherche d\&#39;un sommaire contenant un id/cid, une date et la nature texte recherché
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public displayTextTableOfContentsUsingPOST(sommaireRequest?: LegiSommaireConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).displayTextTableOfContentsUsingPOST(sommaireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des articles par leur identifiant commun
     * @summary Contenu des versions d\'un article
     * @param {ArticleCidRequest} [request] Identifiant technique de l\&#39;article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getArticleByCidUsingPOST(request?: ArticleCidRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getArticleByCidUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un article par son identifiant
     * @summary Contenu d\'un article
     * @param {ArticleRequest} [articleRequest] Identifiant technique de l\&#39;article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getArticleUsingPOST(articleRequest?: ArticleRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getArticleUsingPOST(articleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un Article en fonction de son  ID et Numéro article
     * @summary Contenu d\'un Article
     * @param {ArticleConsultWithIdAndNum} [request] Id et Num
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getArticleWithIdAndNumUsingPOST(request?: ArticleConsultWithIdAndNum, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getArticleWithIdAndNumUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un article par son identifiant Eli ou Alias
     * @summary Contenu d\'un article
     * @param {ArticleIdEliOrAliasRequest} [request] Identifiant Eli ou alias de l\&#39;article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getArticleWithIdEliOrAliasUsingPOST(request?: ArticleIdEliOrAliasRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getArticleWithIdEliOrAliasUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Métadonnées d\'un PDF lié à un texte unitaire BOCC
     * @param {BoccConsultRequest} [request] id du texte BOCC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getBoccTextPdfMetadataUsingPOST(request?: BoccConsultRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getBoccTextPdfMetadataUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un texte du fond CNIL en fonction de son Ancien ID
     * @summary Contenu d\'un texte CNIL
     * @param {CnilConsultWithAncienId} [request] AncienId du texte cible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getCnilWithAncienIdUsingPOST(request?: CnilConsultWithAncienId, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getCnilWithAncienIdUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un Code en fonction de son Ancien ID
     * @summary Contenu d\'un Code
     * @param {CodeConsultWithAncienId} [request] AncienId du code cible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getCodeWithAncienIdUsingPOST(request?: CodeConsultWithAncienId, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getCodeWithAncienIdUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le contenu d\'un texte du fonds JORF à partir de son idEli ou idEliAlias
     * @summary Contenu des textes du JO.
     * @param {JorfConsultWithIdEliAliasRequest} [jorfConsultWithIdEliAliasRequest] idEli ou idEliAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getJoCidWithEliOrAliasUsingPOST(jorfConsultWithIdEliAliasRequest?: JorfConsultWithIdEliAliasRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getJoCidWithEliOrAliasUsingPOST(jorfConsultWithIdEliAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un JO en fonction de son NOR
     * @summary Contenu d\'un JO
     * @param {JorfConsultWithNorRequest} [request] NOR du JO cible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getJoWithNorUsingPOST(request?: JorfConsultWithNorRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getJoWithNorUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un texte du fond juri en fonction de son Ancien ID
     * @summary Contenu d\'un texte juri
     * @param {JuriConsultWithAncienId} [request] AncienId du texte cible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getJuriWithAncienIdUsingPOST(request?: JuriConsultWithAncienId, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getJuriWithAncienIdUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les derniers journaux officiels
     * @summary Derniers journaux officels
     * @param {LastNElementRequest} [request] Nombre de JOs à remonter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getLastNJoUsingPOST(request?: LastNElementRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getLastNJoUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des section par leur identifiant commun
     * @summary Contenu d\'une section
     * @param {SectionCidRequest} [request] Identifiant technique de la section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getSectionByCidUsingPOST(request?: SectionCidRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getSectionByCidUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer l\'ensemble des tables annuelles pour une période donnée
     * @summary Liste des tables annuelles
     * @param {TableRequest} [request] Période en année de la recherche des tables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public getTablesUsingPOST(request?: TableRequest, options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).getTablesUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retourne pong
     * @summary Teste le controller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsultControllerApi
     */
    public pingUsingGET1(options?: AxiosRequestConfig) {
        return ConsultControllerApiFp(this.configuration).pingUsingGET1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ListControllerApi - axios parameter creator
 * @export
 */
export const ListControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives
         * @summary Liste paginée des bulletins officiels des conventions collectives
         * @param {GlobalBoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoccUsingPOST: async (request?: GlobalBoccListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/bocc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives ainsi que leurs textes unitaires
         * @summary Liste paginée des bulletins officiels des conventions collectives
         * @param {BoccAndTextListRequest} [request] Récupère les bulletins officiels des conventions collectives ainsi que leurs textes unitaires dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoccsAndTextsUsingPOST: async (request?: BoccAndTextListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/boccsAndTexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer la liste des bulletins officiels des décorations, médailles et récompenses
         * @summary Liste des bulletins officiels des décorations, médailles et récompenses
         * @param {BodmrListRequest} [request] Récupère les bulletins officiels des décorations, médailles et récompenses dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBodmrUsingPOST: async (request?: BodmrListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/bodmr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les codes dans une liste paginée
         * @summary Liste paginée des codes
         * @param {CodeListRequest} [request] Critères de pagination de la liste code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCodeUsingPOST: async (request?: CodeListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les conventions dans une liste paginée
         * @summary Liste paginée des conventions
         * @param {ConventionsListRequest} [request] Critères de pagination de la liste de conventions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConventionsUsingPOST: async (request?: ConventionsListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/conventions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer la liste des débats parlementaires
         * @summary Liste des débats parlementaires
         * @param {DebatsParlementairesListRequest} [request] Requête de recherche des débats parlementaires
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDebatsParlementairesUsingPOST: async (request?: DebatsParlementairesListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/debatsParlementaires`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer la liste des documents administratifs pour une période donnée
         * @summary Liste des documents administratifs
         * @param {DocsAdminsListRequest} [request] Liste des années recherchées
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocsAdminsUsingPOST: async (request?: DocsAdminsListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/docsAdmins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les dossiers législatifs dans une liste paginée
         * @summary Liste paginée des dossiers législatifs
         * @param {DossiersLegislatifsRequest} [request] Critères de pagination de la liste des dossiers législatifs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDossiersLegislatifsUsingPOST: async (request?: DossiersLegislatifsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/dossiersLegislatifs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les éléments de type LODA dans une liste paginée
         * @summary Liste paginée des textes de type LODA
         * @param {LODAListRequest} [request] Critères de pagination de la liste LODA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLODAUsingPOST: async (request?: LODAListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/loda`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les législatures
         * @summary Liste des législatures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLegislaturesUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/legislatures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer la liste paginée des questions écrites parlementaires
         * @summary Liste paginée des questions écrites parlementaires
         * @param {QuestionsEcritesParlementairesListRequest} [request] Récupère les questions écrites parlementaires dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionsEcritesUsingPOST: async (request?: QuestionsEcritesParlementairesListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/questionsEcritesParlementaires`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer la liste paginée des textes des bulletins officiels des conventions collectives
         * @summary Liste paginée des textes unitaires des bulletins officiels des conventions collectives
         * @param {BoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTextsBoccUsingPOST: async (request?: BoccListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/boccTexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET3: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListControllerApi - functional programming interface
 * @export
 */
export const ListControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives
         * @summary Liste paginée des bulletins officiels des conventions collectives
         * @param {GlobalBoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBoccUsingPOST(request?: GlobalBoccListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoccGlobalListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBoccUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives ainsi que leurs textes unitaires
         * @summary Liste paginée des bulletins officiels des conventions collectives
         * @param {BoccAndTextListRequest} [request] Récupère les bulletins officiels des conventions collectives ainsi que leurs textes unitaires dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBoccsAndTextsUsingPOST(request?: BoccAndTextListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoccGlobalListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBoccsAndTextsUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer la liste des bulletins officiels des décorations, médailles et récompenses
         * @summary Liste des bulletins officiels des décorations, médailles et récompenses
         * @param {BodmrListRequest} [request] Récupère les bulletins officiels des décorations, médailles et récompenses dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBodmrUsingPOST(request?: BodmrListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BodmrListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBodmrUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère les codes dans une liste paginée
         * @summary Liste paginée des codes
         * @param {CodeListRequest} [request] Critères de pagination de la liste code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCodeUsingPOST(request?: CodeListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCodeUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère les conventions dans une liste paginée
         * @summary Liste paginée des conventions
         * @param {ConventionsListRequest} [request] Critères de pagination de la liste de conventions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConventionsUsingPOST(request?: ConventionsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConventionsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConventionsUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer la liste des débats parlementaires
         * @summary Liste des débats parlementaires
         * @param {DebatsParlementairesListRequest} [request] Requête de recherche des débats parlementaires
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDebatsParlementairesUsingPOST(request?: DebatsParlementairesListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DebatsParlementairesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDebatsParlementairesUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer la liste des documents administratifs pour une période donnée
         * @summary Liste des documents administratifs
         * @param {DocsAdminsListRequest} [request] Liste des années recherchées
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocsAdminsUsingPOST(request?: DocsAdminsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocsAdminsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocsAdminsUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère les dossiers législatifs dans une liste paginée
         * @summary Liste paginée des dossiers législatifs
         * @param {DossiersLegislatifsRequest} [request] Critères de pagination de la liste des dossiers législatifs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDossiersLegislatifsUsingPOST(request?: DossiersLegislatifsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DossiersLegislatifsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDossiersLegislatifsUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère les éléments de type LODA dans une liste paginée
         * @summary Liste paginée des textes de type LODA
         * @param {LODAListRequest} [request] Critères de pagination de la liste LODA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLODAUsingPOST(request?: LODAListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LODAListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLODAUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Récupère les législatures
         * @summary Liste des législatures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLegislaturesUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LegislaturesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLegislaturesUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer la liste paginée des questions écrites parlementaires
         * @summary Liste paginée des questions écrites parlementaires
         * @param {QuestionsEcritesParlementairesListRequest} [request] Récupère les questions écrites parlementaires dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuestionsEcritesUsingPOST(request?: QuestionsEcritesParlementairesListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionsEcritesParlementairesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuestionsEcritesUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer la liste paginée des textes des bulletins officiels des conventions collectives
         * @summary Liste paginée des textes unitaires des bulletins officiels des conventions collectives
         * @param {BoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTextsBoccUsingPOST(request?: BoccListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoccTextsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTextsBoccUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingUsingGET3(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingUsingGET3(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListControllerApi - factory interface
 * @export
 */
export const ListControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListControllerApiFp(configuration)
    return {
        /**
         * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives
         * @summary Liste paginée des bulletins officiels des conventions collectives
         * @param {GlobalBoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoccUsingPOST(request?: GlobalBoccListRequest, options?: any): AxiosPromise<BoccGlobalListResponse> {
            return localVarFp.listBoccUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives ainsi que leurs textes unitaires
         * @summary Liste paginée des bulletins officiels des conventions collectives
         * @param {BoccAndTextListRequest} [request] Récupère les bulletins officiels des conventions collectives ainsi que leurs textes unitaires dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoccsAndTextsUsingPOST(request?: BoccAndTextListRequest, options?: any): AxiosPromise<BoccGlobalListResponse> {
            return localVarFp.listBoccsAndTextsUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer la liste des bulletins officiels des décorations, médailles et récompenses
         * @summary Liste des bulletins officiels des décorations, médailles et récompenses
         * @param {BodmrListRequest} [request] Récupère les bulletins officiels des décorations, médailles et récompenses dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBodmrUsingPOST(request?: BodmrListRequest, options?: any): AxiosPromise<BodmrListResponse> {
            return localVarFp.listBodmrUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les codes dans une liste paginée
         * @summary Liste paginée des codes
         * @param {CodeListRequest} [request] Critères de pagination de la liste code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCodeUsingPOST(request?: CodeListRequest, options?: any): AxiosPromise<CodeListResponse> {
            return localVarFp.listCodeUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les conventions dans une liste paginée
         * @summary Liste paginée des conventions
         * @param {ConventionsListRequest} [request] Critères de pagination de la liste de conventions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConventionsUsingPOST(request?: ConventionsListRequest, options?: any): AxiosPromise<ConventionsListResponse> {
            return localVarFp.listConventionsUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer la liste des débats parlementaires
         * @summary Liste des débats parlementaires
         * @param {DebatsParlementairesListRequest} [request] Requête de recherche des débats parlementaires
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDebatsParlementairesUsingPOST(request?: DebatsParlementairesListRequest, options?: any): AxiosPromise<DebatsParlementairesListResponse> {
            return localVarFp.listDebatsParlementairesUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer la liste des documents administratifs pour une période donnée
         * @summary Liste des documents administratifs
         * @param {DocsAdminsListRequest} [request] Liste des années recherchées
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocsAdminsUsingPOST(request?: DocsAdminsListRequest, options?: any): AxiosPromise<DocsAdminsListResponse> {
            return localVarFp.listDocsAdminsUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les dossiers législatifs dans une liste paginée
         * @summary Liste paginée des dossiers législatifs
         * @param {DossiersLegislatifsRequest} [request] Critères de pagination de la liste des dossiers législatifs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDossiersLegislatifsUsingPOST(request?: DossiersLegislatifsRequest, options?: any): AxiosPromise<DossiersLegislatifsListResponse> {
            return localVarFp.listDossiersLegislatifsUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les éléments de type LODA dans une liste paginée
         * @summary Liste paginée des textes de type LODA
         * @param {LODAListRequest} [request] Critères de pagination de la liste LODA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLODAUsingPOST(request?: LODAListRequest, options?: any): AxiosPromise<LODAListResponse> {
            return localVarFp.listLODAUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les législatures
         * @summary Liste des législatures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLegislaturesUsingPOST(options?: any): AxiosPromise<LegislaturesListResponse> {
            return localVarFp.listLegislaturesUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer la liste paginée des questions écrites parlementaires
         * @summary Liste paginée des questions écrites parlementaires
         * @param {QuestionsEcritesParlementairesListRequest} [request] Récupère les questions écrites parlementaires dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestionsEcritesUsingPOST(request?: QuestionsEcritesParlementairesListRequest, options?: any): AxiosPromise<QuestionsEcritesParlementairesListResponse> {
            return localVarFp.listQuestionsEcritesUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer la liste paginée des textes des bulletins officiels des conventions collectives
         * @summary Liste paginée des textes unitaires des bulletins officiels des conventions collectives
         * @param {BoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTextsBoccUsingPOST(request?: BoccListRequest, options?: any): AxiosPromise<BoccTextsListResponse> {
            return localVarFp.listTextsBoccUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET3(options?: any): AxiosPromise<string> {
            return localVarFp.pingUsingGET3(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListControllerApi - object-oriented interface
 * @export
 * @class ListControllerApi
 * @extends {BaseAPI}
 */
export class ListControllerApi extends BaseAPI {
    /**
     * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives
     * @summary Liste paginée des bulletins officiels des conventions collectives
     * @param {GlobalBoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listBoccUsingPOST(request?: GlobalBoccListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listBoccUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer la liste paginée des bulletins officiels des conventions collectives ainsi que leurs textes unitaires
     * @summary Liste paginée des bulletins officiels des conventions collectives
     * @param {BoccAndTextListRequest} [request] Récupère les bulletins officiels des conventions collectives ainsi que leurs textes unitaires dans une liste paginée
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listBoccsAndTextsUsingPOST(request?: BoccAndTextListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listBoccsAndTextsUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer la liste des bulletins officiels des décorations, médailles et récompenses
     * @summary Liste des bulletins officiels des décorations, médailles et récompenses
     * @param {BodmrListRequest} [request] Récupère les bulletins officiels des décorations, médailles et récompenses dans une liste paginée
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listBodmrUsingPOST(request?: BodmrListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listBodmrUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les codes dans une liste paginée
     * @summary Liste paginée des codes
     * @param {CodeListRequest} [request] Critères de pagination de la liste code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listCodeUsingPOST(request?: CodeListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listCodeUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les conventions dans une liste paginée
     * @summary Liste paginée des conventions
     * @param {ConventionsListRequest} [request] Critères de pagination de la liste de conventions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listConventionsUsingPOST(request?: ConventionsListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listConventionsUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer la liste des débats parlementaires
     * @summary Liste des débats parlementaires
     * @param {DebatsParlementairesListRequest} [request] Requête de recherche des débats parlementaires
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listDebatsParlementairesUsingPOST(request?: DebatsParlementairesListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listDebatsParlementairesUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer la liste des documents administratifs pour une période donnée
     * @summary Liste des documents administratifs
     * @param {DocsAdminsListRequest} [request] Liste des années recherchées
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listDocsAdminsUsingPOST(request?: DocsAdminsListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listDocsAdminsUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les dossiers législatifs dans une liste paginée
     * @summary Liste paginée des dossiers législatifs
     * @param {DossiersLegislatifsRequest} [request] Critères de pagination de la liste des dossiers législatifs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listDossiersLegislatifsUsingPOST(request?: DossiersLegislatifsRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listDossiersLegislatifsUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les éléments de type LODA dans une liste paginée
     * @summary Liste paginée des textes de type LODA
     * @param {LODAListRequest} [request] Critères de pagination de la liste LODA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listLODAUsingPOST(request?: LODAListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listLODAUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les législatures
     * @summary Liste des législatures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listLegislaturesUsingPOST(options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listLegislaturesUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer la liste paginée des questions écrites parlementaires
     * @summary Liste paginée des questions écrites parlementaires
     * @param {QuestionsEcritesParlementairesListRequest} [request] Récupère les questions écrites parlementaires dans une liste paginée
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listQuestionsEcritesUsingPOST(request?: QuestionsEcritesParlementairesListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listQuestionsEcritesUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer la liste paginée des textes des bulletins officiels des conventions collectives
     * @summary Liste paginée des textes unitaires des bulletins officiels des conventions collectives
     * @param {BoccListRequest} [request] Récupère les bulletins officiels des conventions collectives dans une liste paginée
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listTextsBoccUsingPOST(request?: BoccListRequest, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listTextsBoccUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retourne pong
     * @summary Teste le controller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public pingUsingGET3(options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).pingUsingGET3(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MiscControllerApi - axios parameter creator
 * @export
 */
export const MiscControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Récupère les informations relatives au déploiement et au versionning de l\'application
         * @summary Informations déploiement et versionning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitIdUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/misc/commitId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer l\'ensemble des dates pour lesquelles il n\'existe pas de Journal Officiel
         * @summary Liste des dates sans JO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatesWithoutJoUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/misc/datesWithoutJo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer l\'ensemble des années sans table annuelle
         * @summary Liste des années sans table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYearsWithoutTableUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/misc/yearsWithoutTable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscControllerApi - functional programming interface
 * @export
 */
export const MiscControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Récupère les informations relatives au déploiement et au versionning de l\'application
         * @summary Informations déploiement et versionning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommitIdUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommitIdUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer l\'ensemble des dates pour lesquelles il n\'existe pas de Journal Officiel
         * @summary Liste des dates sans JO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatesWithoutJoUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatesWithNoJoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatesWithoutJoUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer l\'ensemble des années sans table annuelle
         * @summary Liste des années sans table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYearsWithoutTableUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<YearsWithNoTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getYearsWithoutTableUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiscControllerApi - factory interface
 * @export
 */
export const MiscControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscControllerApiFp(configuration)
    return {
        /**
         * Récupère les informations relatives au déploiement et au versionning de l\'application
         * @summary Informations déploiement et versionning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitIdUsingGET(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getCommitIdUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer l\'ensemble des dates pour lesquelles il n\'existe pas de Journal Officiel
         * @summary Liste des dates sans JO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatesWithoutJoUsingGET(options?: any): AxiosPromise<DatesWithNoJoResponse> {
            return localVarFp.getDatesWithoutJoUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer l\'ensemble des années sans table annuelle
         * @summary Liste des années sans table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYearsWithoutTableUsingGET(options?: any): AxiosPromise<YearsWithNoTableResponse> {
            return localVarFp.getYearsWithoutTableUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscControllerApi - object-oriented interface
 * @export
 * @class MiscControllerApi
 * @extends {BaseAPI}
 */
export class MiscControllerApi extends BaseAPI {
    /**
     * Récupère les informations relatives au déploiement et au versionning de l\'application
     * @summary Informations déploiement et versionning
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscControllerApi
     */
    public getCommitIdUsingGET(options?: AxiosRequestConfig) {
        return MiscControllerApiFp(this.configuration).getCommitIdUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer l\'ensemble des dates pour lesquelles il n\'existe pas de Journal Officiel
     * @summary Liste des dates sans JO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscControllerApi
     */
    public getDatesWithoutJoUsingGET(options?: AxiosRequestConfig) {
        return MiscControllerApiFp(this.configuration).getDatesWithoutJoUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer l\'ensemble des années sans table annuelle
     * @summary Liste des années sans table
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscControllerApi
     */
    public getYearsWithoutTableUsingGET(options?: AxiosRequestConfig) {
        return MiscControllerApiFp(this.configuration).getYearsWithoutTableUsingGET(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchControllerApi - axios parameter creator
 * @export
 */
export const SearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET4: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer les versions d\'un article
         * @summary Récupération des versions de l\'article
         * @param {ArticleRequest} [request] Identifiant commun de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCanonicalArticleVersionUsingPOST: async (request?: ArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/canonicalArticleVersion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer la date de debut de la version canonique d\'un texte
         * @summary Récupération des infos de la version canonique
         * @param {SearchCanonicalVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCanonicalVersionUsingPOST: async (request?: SearchCanonicalVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/canonicalVersion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de récupérer le titre et la section de la version d\'un texte la plus proche d\'une date donnée
         * @summary Récupération des infos de la version la plus proche
         * @param {SearchNearestVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNearestVersionUsingPOST: async (request?: SearchNearestVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/nearestVersion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permet de faire une recherche de documents. On peut préciser le fond, les filtres textuels, les facettes et la pagination
         * @summary Recherche générique des documents indexés
         * @param {SearchRequestDTO} [jsonRequest] Requête de recherche porteur du/des fonds ciblés, des filtres et des informations de pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsingPOST: async (jsonRequest?: SearchRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchControllerApi - functional programming interface
 * @export
 */
export const SearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingUsingGET4(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingUsingGET4(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer les versions d\'un article
         * @summary Récupération des versions de l\'article
         * @param {ArticleRequest} [request] Identifiant commun de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCanonicalArticleVersionUsingPOST(request?: ArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchCanonicalArticleVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCanonicalArticleVersionUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer la date de debut de la version canonique d\'un texte
         * @summary Récupération des infos de la version canonique
         * @param {SearchCanonicalVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCanonicalVersionUsingPOST(request?: SearchCanonicalVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchCanonicalVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCanonicalVersionUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de récupérer le titre et la section de la version d\'un texte la plus proche d\'une date donnée
         * @summary Récupération des infos de la version la plus proche
         * @param {SearchNearestVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchNearestVersionUsingPOST(request?: SearchNearestVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchNearestVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchNearestVersionUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permet de faire une recherche de documents. On peut préciser le fond, les filtres textuels, les facettes et la pagination
         * @summary Recherche générique des documents indexés
         * @param {SearchRequestDTO} [jsonRequest] Requête de recherche porteur du/des fonds ciblés, des filtres et des informations de pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsingPOST(jsonRequest?: SearchRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsingPOST(jsonRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchControllerApi - factory interface
 * @export
 */
export const SearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchControllerApiFp(configuration)
    return {
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET4(options?: any): AxiosPromise<string> {
            return localVarFp.pingUsingGET4(options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer les versions d\'un article
         * @summary Récupération des versions de l\'article
         * @param {ArticleRequest} [request] Identifiant commun de l\&#39;article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCanonicalArticleVersionUsingPOST(request?: ArticleRequest, options?: any): AxiosPromise<SearchCanonicalArticleVersionResponse> {
            return localVarFp.searchCanonicalArticleVersionUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer la date de debut de la version canonique d\'un texte
         * @summary Récupération des infos de la version canonique
         * @param {SearchCanonicalVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCanonicalVersionUsingPOST(request?: SearchCanonicalVersionRequest, options?: any): AxiosPromise<SearchCanonicalVersionResponse> {
            return localVarFp.searchCanonicalVersionUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de récupérer le titre et la section de la version d\'un texte la plus proche d\'une date donnée
         * @summary Récupération des infos de la version la plus proche
         * @param {SearchNearestVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNearestVersionUsingPOST(request?: SearchNearestVersionRequest, options?: any): AxiosPromise<SearchNearestVersionResponse> {
            return localVarFp.searchNearestVersionUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Permet de faire une recherche de documents. On peut préciser le fond, les filtres textuels, les facettes et la pagination
         * @summary Recherche générique des documents indexés
         * @param {SearchRequestDTO} [jsonRequest] Requête de recherche porteur du/des fonds ciblés, des filtres et des informations de pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsingPOST(jsonRequest?: SearchRequestDTO, options?: any): AxiosPromise<SearchResponseDTO> {
            return localVarFp.searchUsingPOST(jsonRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchControllerApi - object-oriented interface
 * @export
 * @class SearchControllerApi
 * @extends {BaseAPI}
 */
export class SearchControllerApi extends BaseAPI {
    /**
     * Retourne pong
     * @summary Teste le controller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public pingUsingGET4(options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).pingUsingGET4(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer les versions d\'un article
     * @summary Récupération des versions de l\'article
     * @param {ArticleRequest} [request] Identifiant commun de l\&#39;article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public searchCanonicalArticleVersionUsingPOST(request?: ArticleRequest, options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).searchCanonicalArticleVersionUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer la date de debut de la version canonique d\'un texte
     * @summary Récupération des infos de la version canonique
     * @param {SearchCanonicalVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public searchCanonicalVersionUsingPOST(request?: SearchCanonicalVersionRequest, options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).searchCanonicalVersionUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de récupérer le titre et la section de la version d\'un texte la plus proche d\'une date donnée
     * @summary Récupération des infos de la version la plus proche
     * @param {SearchNearestVersionRequest} [request] Date de recherche / Identifiant commun du texte / Identifiant commun de la section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public searchNearestVersionUsingPOST(request?: SearchNearestVersionRequest, options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).searchNearestVersionUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permet de faire une recherche de documents. On peut préciser le fond, les filtres textuels, les facettes et la pagination
     * @summary Recherche générique des documents indexés
     * @param {SearchRequestDTO} [jsonRequest] Requête de recherche porteur du/des fonds ciblés, des filtres et des informations de pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public searchUsingPOST(jsonRequest?: SearchRequestDTO, options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).searchUsingPOST(jsonRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SuggestControllerApi - axios parameter creator
 * @export
 */
export const SuggestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Effectue les diverses suggestions sur les différents fonds à partir d\'une chaine de caractères et de la liste des fonds sélectionnés
         * @summary Suggestions de résultats
         * @param {SuggestSupplyRequest} [request] Critères de recherche de suggestion (texte et fonds ciblés)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crossSearchUsingPOST: async (request?: SuggestSupplyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/suggest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Effectue les suggestions des libellés sur les plans de classements à partir d\'une chaine de caractères
         * @summary Suggestions des libellés pour les plans de classement
         * @param {SuggestPdcRequest} [request] Critères de recherche de suggestion (texte)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pdcSuggestUsingPOST: async (request?: SuggestPdcRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/suggest/pdc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET5: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/suggest/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Effectue les suggestions siret et raisons sociales sur les accords d\'entreprise à partir d\'une chaine de caractères
         * @summary Suggestions des siret et raisons sociale pour les accords
         * @param {SuggestRequest} [request] Critères de recherche de suggestion (texte)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siretRcSuggestUsingPOST: async (request?: SuggestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/suggest/acco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuthImplicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthImplicit", ["openid"], configuration)

            // authentication OAuthAccessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuthAccessCode", ["openid"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestControllerApi - functional programming interface
 * @export
 */
export const SuggestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SuggestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Effectue les diverses suggestions sur les différents fonds à partir d\'une chaine de caractères et de la liste des fonds sélectionnés
         * @summary Suggestions de résultats
         * @param {SuggestSupplyRequest} [request] Critères de recherche de suggestion (texte et fonds ciblés)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crossSearchUsingPOST(request?: SuggestSupplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crossSearchUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Effectue les suggestions des libellés sur les plans de classements à partir d\'une chaine de caractères
         * @summary Suggestions des libellés pour les plans de classement
         * @param {SuggestPdcRequest} [request] Critères de recherche de suggestion (texte)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pdcSuggestUsingPOST(request?: SuggestPdcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pdcSuggestUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingUsingGET5(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingUsingGET5(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Effectue les suggestions siret et raisons sociales sur les accords d\'entreprise à partir d\'une chaine de caractères
         * @summary Suggestions des siret et raisons sociale pour les accords
         * @param {SuggestRequest} [request] Critères de recherche de suggestion (texte)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siretRcSuggestUsingPOST(request?: SuggestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestAccoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siretRcSuggestUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SuggestControllerApi - factory interface
 * @export
 */
export const SuggestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SuggestControllerApiFp(configuration)
    return {
        /**
         * Effectue les diverses suggestions sur les différents fonds à partir d\'une chaine de caractères et de la liste des fonds sélectionnés
         * @summary Suggestions de résultats
         * @param {SuggestSupplyRequest} [request] Critères de recherche de suggestion (texte et fonds ciblés)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crossSearchUsingPOST(request?: SuggestSupplyRequest, options?: any): AxiosPromise<SuggestResponse> {
            return localVarFp.crossSearchUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Effectue les suggestions des libellés sur les plans de classements à partir d\'une chaine de caractères
         * @summary Suggestions des libellés pour les plans de classement
         * @param {SuggestPdcRequest} [request] Critères de recherche de suggestion (texte)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pdcSuggestUsingPOST(request?: SuggestPdcRequest, options?: any): AxiosPromise<SuggestResponse> {
            return localVarFp.pdcSuggestUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retourne pong
         * @summary Teste le controller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingUsingGET5(options?: any): AxiosPromise<string> {
            return localVarFp.pingUsingGET5(options).then((request) => request(axios, basePath));
        },
        /**
         * Effectue les suggestions siret et raisons sociales sur les accords d\'entreprise à partir d\'une chaine de caractères
         * @summary Suggestions des siret et raisons sociale pour les accords
         * @param {SuggestRequest} [request] Critères de recherche de suggestion (texte)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siretRcSuggestUsingPOST(request?: SuggestRequest, options?: any): AxiosPromise<SuggestAccoResponse> {
            return localVarFp.siretRcSuggestUsingPOST(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SuggestControllerApi - object-oriented interface
 * @export
 * @class SuggestControllerApi
 * @extends {BaseAPI}
 */
export class SuggestControllerApi extends BaseAPI {
    /**
     * Effectue les diverses suggestions sur les différents fonds à partir d\'une chaine de caractères et de la liste des fonds sélectionnés
     * @summary Suggestions de résultats
     * @param {SuggestSupplyRequest} [request] Critères de recherche de suggestion (texte et fonds ciblés)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestControllerApi
     */
    public crossSearchUsingPOST(request?: SuggestSupplyRequest, options?: AxiosRequestConfig) {
        return SuggestControllerApiFp(this.configuration).crossSearchUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Effectue les suggestions des libellés sur les plans de classements à partir d\'une chaine de caractères
     * @summary Suggestions des libellés pour les plans de classement
     * @param {SuggestPdcRequest} [request] Critères de recherche de suggestion (texte)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestControllerApi
     */
    public pdcSuggestUsingPOST(request?: SuggestPdcRequest, options?: AxiosRequestConfig) {
        return SuggestControllerApiFp(this.configuration).pdcSuggestUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retourne pong
     * @summary Teste le controller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestControllerApi
     */
    public pingUsingGET5(options?: AxiosRequestConfig) {
        return SuggestControllerApiFp(this.configuration).pingUsingGET5(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Effectue les suggestions siret et raisons sociales sur les accords d\'entreprise à partir d\'une chaine de caractères
     * @summary Suggestions des siret et raisons sociale pour les accords
     * @param {SuggestRequest} [request] Critères de recherche de suggestion (texte)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestControllerApi
     */
    public siretRcSuggestUsingPOST(request?: SuggestRequest, options?: AxiosRequestConfig) {
        return SuggestControllerApiFp(this.configuration).siretRcSuggestUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }
}



